{
    "version": "https://jsonfeed.org/version/1",
    "title": "该死的秋招",
    "description": "孵化中···",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/10/24/cas/",
            "url": "http://example.com/2023/10/24/cas/",
            "title": "cas",
            "date_published": "2023-10-24T02:52:52.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>先前对于 cas 的了解也就是停止在基本的概念层，现在也不是很深入，但是比之前强点。</p>\n<h3 id=\"cas是什么\"><a class=\"markdownIt-Anchor\" href=\"#cas是什么\">#</a> cas 是什么</h3>\n<p>compare and switch，比较并交换，存在着三个变量，拷贝的旧值 A，需要更改的新值 B，内存中的值 C；如果 A 和 C 相等的话，那么我就将 B 覆盖掉 C，否则一直重复上述过程。</p>\n<h3 id=\"cas如何实现的\"><a class=\"markdownIt-Anchor\" href=\"#cas如何实现的\">#</a> cas 如何实现的</h3>\n<p>对于 cas 来说，我涉及到比较并交换的过程，涉及到读取和修改，那么多线程之下，如果不是原子性的操作必然会出现问题，也就是说我这些操作要么一起完成，要么一起不完成，对于单条指令通过 cmpradexchange 就可以完成，但是多核的情况下，需要协同多个 cpu，所以底层的汇编指令就是 lock compareandexchange。</p>\n<h3 id=\"经典的aba问题\"><a class=\"markdownIt-Anchor\" href=\"#经典的aba问题\">#</a> 经典的 aba 问题</h3>\n<p>马士兵说 cas 存在着两个问题，一个是 aba，比较简单，通过版本号来控制，具体版本号通过 boolean，int 还是时间戳都随便。<br>\n第二个就是我上面讲的原子性问题，他的出发角度就是 cas 的具体实现的问题，要实现 cas，必须要确保这一套是原子操作，所以需要操作系统层面，硬件层面支持 lock 这个指令。</p>\n",
            "tags": [
                "多线程"
            ]
        },
        {
            "id": "http://example.com/2023/10/24/synchronized/",
            "url": "http://example.com/2023/10/24/synchronized/",
            "title": "synchronized",
            "date_published": "2023-10-24T01:55:44.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>对于 synchronized 一直理解就那样，最近学到一点关于对象结构以及锁升级的具体详细的情况，做个记录</p>\n<h3 id=\"classlayout\"><a class=\"markdownIt-Anchor\" href=\"#classlayout\">#</a> classlayout</h3>\n<p>对于 object o = new object (); 具体的 jvm 内的情况就是刨去类加载不说，现在要说的是给对象在 jvm 堆中分配内存空间。然后线程栈帧中分配一个变量 o 指向堆中 new 出来的对象。那么这个堆中的对象到底是怎样一个情况呢。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/65372b89c458853aef883bbf.jpg\" alt=\"\"><br>\n大致的情况，上图就是一个对象的 layout，其中</p>\n<ul>\n<li>对象头，包括 mark word（8 字节）和 class pointer（开启压缩 4 字节，不开压缩 8 字节），如果是数组的话还会包括一个 4 字节的数组长度。所以说数组最大长度 2^32 -1; 最重要的就是 mark word 中的信息了，其中包括了锁信息以及 hashcode 信息（延迟加载）还有 gc 信息等。</li>\n<li>实例数据，如果有属性的话，就是属性字段，用到了父类的属性也有父类的信息</li>\n<li>空白填充，也就是 jvm 64 的要求，对象的开始必须是 8 字节的整数倍，所以需要填充</li>\n</ul>\n<h3 id=\"synchronized锁升级\"><a class=\"markdownIt-Anchor\" href=\"#synchronized锁升级\">#</a> synchronized 锁升级</h3>\n<p>在 1.6 之前，synchronized 是没有升级过程的，直接使用 mutex lock，互斥锁。也就是所谓的重量级锁。</p>\n<p>对于什么偏向锁，轻量级锁，重量级锁的概念，也就只有重量级锁才是真正的上锁，也就是将线程入队列，交给了 os 进行管理，会涉及到用户态和内核态的转化。其余的都相当于没上锁，也就是在用户态的层面完成了线程的同步管理。</p>\n<p>背景：当一个资源是共享资源的时候，那么如果在多线程的环境下我们需要保证线程安全的话也就是满足线程三要素，那么就可以通过 synchronized 完成，所以说这个背景是已经加上了 synchronized 字段了。那么改进了一上来就重量级锁的情况，四个状态出现了。</p>\n<ul>\n<li>无锁，001，也就是没有线程用到这个资源的时候，这个对象 mark word 中的锁信息</li>\n<li>当有线程要用到的时候，A 线程看到 01，并且前面是 0，那么上偏向锁，通过 cas 的方式将其中的 0 改成 1，并且将自己的 threadid 给放到前面去（当前线程指针）。这边说一下为什么要 cas，因为可能有多个线程同时看到 01，然后去修改，那么这时候是存在竞争的（隐式竞争），所以只要修改资源，就 cas 活锁。</li>\n<li>那么 B 线程看到了 101，需要再看看前面的 threadid 是不是自己，如果不是的话，锁升级 00，轻量级锁。这边的细节就是前面的指针信息换了，换成了每个线程在自己的线程栈中生成一条 lock record，然后将对象头中的前面的字段指向 lock record，完成上锁（至于这边也是有疑问的，为什么还不是直接用各自的 threadid），其实也是没锁的，就是上个字段。</li>\n<li>如果 00 锁，cas 自选到一定程度，10 次？那么锁升级，线程入队直接交给 os 处理，并且其中的锁信息也是换成了真正的锁 monitor，通过加上 monitor enter 和 monitor exit 来完成整段的汇编指令。</li>\n</ul>\n<p>其中应该是有 cas 自旋优化的，也就是 epoch 字段，但是不了解，大致的说法貌似式如果上次通过 cas 获取到了锁，那么这次就延长 cas 的时间，如果上次 cas 没有获取到，那么缩短。但是疑问就是没有 cas 到不就锁升级了么，不知道怎么事他娘的。</p>\n<h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>大致的一整个 synchronized 就结束了，目前感觉挺通透的。</p>\n",
            "tags": [
                "多线程"
            ]
        },
        {
            "id": "http://example.com/2023/10/23/volatile/",
            "url": "http://example.com/2023/10/23/volatile/",
            "title": "volatile",
            "date_published": "2023-10-23T03:05:46.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>对于 volatile，很神奇，玛德，感觉懂了，但是每次一回想总感觉差点什么。</p>\n<h3 id=\"缓存行\"><a class=\"markdownIt-Anchor\" href=\"#缓存行\">#</a> 缓存行</h3>\n<p>缓存行也是最近刚刷新的一个概念，对于线程来说，都会将内存中的数据缓存到各自的缓存中，也就是所谓的 cache。那么这个 cache 是怎么读取的呢，一行 64 字节，所以如果需要读取的变量在这一行上，那么就会将这一整行读进来，也就是说 cache 读取的最小单位是 64 字节。</p>\n<h3 id=\"缓存一致性\"><a class=\"markdownIt-Anchor\" href=\"#缓存一致性\">#</a> 缓存一致性</h3>\n<p>那么如何保证缓存一致性呢？<br>\n有一种现象，两个线程，读取了同一个缓存行，两个都对这个缓存行上的数据进行了修改，那么当一个修改完了，没有通知另一个的时候，这个时候就出现了不一致的问题，也就是经典的多线程的问题。</p>\n<h3 id=\"volatile\"><a class=\"markdownIt-Anchor\" href=\"#volatile\">#</a> volatile</h3>\n<p>引入今天的主角，volatile<br>\nvolatile 有两个特性，可见性和一致性（多线程三大特性，满足两个），那么是如何保证的呢。个人感觉说这两个特性有点抽象，其实 volatile 干的事就是强制走主存并且禁止指令重排（加入了内存屏障 ss 写 sl； ll 读 ls）</p>\n<p>volatile 的规范有这两个，当读取 volatile 的时候必须从主存中进行读取（也就是跨过缓存，读主存，然后将主存中的数据再读到缓存中来），修改完 volatile 变量后同步到主存中。但是像 i++ 这样需要读取，然后再赋值的情况，volatile 就解决不了。</p>\n<p>为什么解决不了呢，网上有从 cpu 的结构出发的 cpu 包括 pc 寄存器 以及 alu；有个说法是读取 m 的值到寄存器中了，那么这个 m 值发生变化的话，只会影响到 cpu 缓存并不会干涉到寄存器，所以 invalid 就不行。另外一个说的是虽然读到了，但是执行了 + 1 操作，这个时候进行 store，是不会进行重新读取的，如果没有进行 + 1 操作，那么 m 值 invalid 之后还是会进行重新读取的。</p>\n<p>目前个人更偏向于后者，前者感觉有点问题，但也说不出哪里有问题 hhhh</p>\n<p>但是看到了一个很有意思的评论：线程安全是由这三大问题导致的：</p>\n<ul>\n<li>cpu 缓存引起的可见性问题，缓存与主存</li>\n<li>cpu 指令重排，引起的顺序问题</li>\n<li>cpu 切换，线程中断引起的原子性问题，也就是 cpu 切换</li>\n</ul>\n",
            "tags": [
                "JUC"
            ]
        },
        {
            "id": "http://example.com/2023/10/22/threadlocal/",
            "url": "http://example.com/2023/10/22/threadlocal/",
            "title": "threadlocal",
            "date_published": "2023-10-22T08:08:16.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>threadlocal，线程的本地变量</p>\n<h3 id=\"强软弱虚引用\"><a class=\"markdownIt-Anchor\" href=\"#强软弱虚引用\">#</a> 强软弱虚引用</h3>\n<p>了解 threadlocal 之前，就需要了解引用的类型，因为 threadlocal 用到了弱引用。</p>\n<p>这边提一嘴 gc 的问题，gc 触发的时间根据 gc 算法（我记忆中目前能够理清楚的是这样）不同，gc 的时间点也不同，分 young 和 old gc，所以说这个 gc 触发的时候，你的引用有的是还在的，那么强引用就是 gc 不掉的，也就是还没出我的作用域呢，也就是还存活呢。那么对于软引用，空间满了，不管你还有没有在用呢，直接 gc。对于弱引用，只要 gc 触发看到了，不管满没满，直接 gc</p>\n<ul>\n<li>强引用：对于 object o = new object (); 这样的 o 指向的引用就是强引用。</li>\n<li>软引用：很少使用，但是有他的使用场景，对于特别大的图片，如果使用强引用，那么就很占地方，gc 不了，如果，用一下就给 gc 了，那么每次用都要 load，这样很耗时，所以软引用来了，只有当 jvm 堆空间满了，那么 gc 软引用。使用方法 softregerence&lt;byte []&gt; m = new softreference&lt;&gt;(new byte [1024<em>1024</em>10]); 好像是套壳引用，也就是我要用个 byte 数组的时候，这个时候将它放在软引用的 new 里面。 那么这个 softreference 占不占空间呢，肯定站，但是估计是个空壳。</li>\n<li>弱引用：weakreference，当遇到 gc 的时候，直接被回收。</li>\n<li>虚引用：phantomreference，不咋用。特点就是你放在里面，get 是 get 不到的，但是弱引用只要没被回收还是能够 get 到的。他只有一个应用场景，堆外内存，零拷贝的起始点。也就是 java 里面有对象是关联着堆外的内存中的对象的，这个 java 里面的就用虚引用给他标记起来，然后有个专门的队列管理着这些虚引用，如果回收这个对象就需要将其关联的堆外内存也回收掉，不然就是内存泄漏。零拷贝和 NIO 都是用的虚引用</li>\n</ul>\n<h3 id=\"threadlocal\"><a class=\"markdownIt-Anchor\" href=\"#threadlocal\">#</a> threadlocal</h3>\n<p>这边就来讲一下 threadlocal<br>\n<img data-src=\"https://pic.imgdb.cn/item/65352e91c458853aefda70bb.jpg\" alt=\"\"><br>\n 当线程中使用 threadlocal，放对象进去的时候，是往线程的 threadlocalmap 中存放 key 为 threadlocal，value 为放进去的对象的 entry。这个 entry 是继承的 weakreference，他的 key 是一个弱引用。</p>\n<p>这么设计的好处就是，当有多个线程指向这个 threadlocal 的时候，如果不用了，那么就会 gc 掉，所以如果是强引用的话，那么将很难被 gc，因为这边不用了指不定有多少线程在用，这将造成 threadlocal 这块的内存泄漏。但是有另外的一个问题，就是现在这个 key 是弱引用，所以当我外面的强引用被 gc 掉之后，这个弱引用就指向 null 了，但是 value 是强引用，导致 value 回收不掉。所以使用完了需要使用 threadlocal 的 remove，这个会回收掉 key 为 null 的 entry。</p>\n<p>这边注意一点，对于 entry 的 key 和 value 是分开回收的。</p>\n",
            "tags": [
                "JUC"
            ]
        },
        {
            "id": "http://example.com/2023/10/21/JUC%E7%9B%B8%E5%85%B3%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%B1%E5%86%99/",
            "url": "http://example.com/2023/10/21/JUC%E7%9B%B8%E5%85%B3%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%B1%E5%86%99/",
            "title": "JUC",
            "date_published": "2023-10-21T03:56:44.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>其实最近也比较浮躁，所以就开始刷一些视频，看 blog 或者书籍，有点看不下去。选择看什么视频的时候，就想到了一直在看，但是总感觉没有懂的 JUC，然后就慢慢的深入，从 java 的 JUC 的底层，从加锁不同的锁到 cas，然后 aqs，然后就是一堆 JUC 工具包对 aqs 的实现，然后还是很摸棱两可，到底会不会，如会，，，懂不懂，如懂，，，玛德，所以有些小无奈，知道今天特么看到了马士兵的教学视频，特么感觉问题点应该是出在操作系统这一块，他讲了一个虽然我一直知道，但是到那一刻才豁然的学习道理，先大再小。我反思了</p>\n<p>我一直以为我都是先大后小，先整体再细节，先大的模块再深入分解，但是我好像对于操作系统这块，线程是怎么和底层的资源进行交互的这块，并没有加入到整体的框架中来，也就是并不完整。所以我的深入就会令我不时的产生疑惑。</p>\n<p>他讲到了一个点：app 也就是所谓的软件是完全可以和硬件打交道的，也就是我们可以直接将软件建立在硬件之上（个人理解就是汇编咯，也不是说其他的语言不可以，如果可以的话估计名字就得换了），比如我们的 java，他是建立在 jvm 之上，又建立在操作系统之上然后再去接触硬件的。这也就是涉及到了历史的发展，刚开始确实是这么干的，但是 bug 频繁的触发，然后诞生了一个中间的软件 OS，也就是你们都太垃圾了，我来干硬件，然后我提供接口给你们，你们来干我，这样难度小一点。特么的真有道理，所以我们现在的软件都建立在操作系统之上。</p>\n<p>然后再来一条路，就是 JVM 这条路，可以理解 JVM 就是一个 app，当然了他只是一种规范，实现有很多种方法，最熟悉的 hotspot 就是我们常用的 JVM。这也是最近刚豁然的一个点，JVM 内存模型中有两个栈，虚拟机栈和 native 本地栈，当时一直不懂为什么要分两个。后来才明白本地栈就是对本地方法的调用，但是其实还是没懂，为什么这么说呢。</p>\n<p>因为啊，当看 JVM 底层对于 juc 的实现，其中 compareandswap 是 unsafe 这个类的方法，这个呢就是一个本地方法，这个是用 c<ins> 写的，也是 hotspot 虚拟机的实现里才能看间源码的，他的底层有一个 cmandchange 方法，这个呢就是涉及到汇编了貌似或者说还是 c</ins> 不是很懂。这里就突然想到我们下载无论什么 app 都有版本什么 x86，linux，windows，ios，这里才明白，这就是上层软件的实现对于操作系统的调用，所以不同的操作系统这一块的实现都是不同的。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/6533dbedc458853aefd86a15.jpg\" alt=\"\"><br>\n记录一下对于 static 和 volatile 的区别，也就是所谓的可见性的问题<br>\n我们所了解到的，static 静态变量在 1.8 的时候被移到了堆中，那么无论是堆还是方法区都是线程间共享的。这里，第一次刷新了我的认知，也是错误的认知</p>\n<p>我们知道局部变量，也就是方法中的，那么是在线程栈里面的，也就是出栈就销毁的，也就是没有所谓的 gc。并且局部，也代表着没有所谓的共享，那么就是多线程是读不到的，也就是局部变量不允许被共享，他们是被分配在栈帧中的。有趣的来了<br>\n我以前从未这样用过 static 或者 volatile，也就是在类的方法中声明 static 或者 volatile 变量，今天试了一下，直接报错，这意味着什么！！</p>\n<p>这意味着我将局部变量，分配在栈帧中的变量，尝试着给他拉到堆中，这本身就不可能。所以 checked exception 直接报错。</p>\n<p>接着就是我改变了这个认知，只有 static 静态变量，类级别的成员变量才有可能被线程可见，因为他们是堆中的，他们本身的属性是共享属性。也就是他们出了栈帧还能存活。来了，也就是今天刚弄懂的 static 和 volatile</p>\n<p>static 只是允许多线程读取，可见性的意思也并不是 “可读”，而是一个线程修改了，那么其他的线程能够立刻获取到其被修改了的信息。所以 static 只是保证了可读，多个线程可以读这个变量，可以拷贝过去，什么时候刷到主存呢，不确定。上面那个图很神奇，是我做的一个实验，也就是 static 变量，修改看能不能读取到，确实是可以的，但是如果循环体中没有语句的话，是不会读取到的，应该是底层做了优化了，也就是没有循环体的话，我就不会去主存中读取这个 static 变量，那么久不会检测到这个变量被修改了，很离谱就是，幸亏看到网上有说，然后我加了个循环体，然后就能退出循环了。证明了 static 变量在多线程之间是可以读取到的。</p>\n<p>这边涉及到一个概念，锁缓存行，锁总线，挺神奇的。在我们正常的理解下面，是一个线程修改了数据，因为读取缓存是以行为单位读取的，那么如果缓存一致性的情况下，另外一个线程也获取到了这块缓存行里面的数据，那么就需要通知了。所以说有的为了避免通知，也就是减少同步，就使用了缓存行对齐。</p>\n<p>缓存行：64 字节，long 8 字节，那么对其 long 的话，就前后各放 7 个无关的常量 long 即可，如果 x，y 在一个缓存行里面，那么一个线程读了 x，另一个读了 y。如果修改了其中一个，那么就需要通知另外一个线程更新这个缓存行，这样保证了缓存一致。如果 x，y 在两行，那么修改就不要通知另外一个线程。</p>\n<p>如果需要对不同行进行加锁，那么就需要锁总线</p>\n<h3 id=\"cpu\"><a class=\"markdownIt-Anchor\" href=\"#cpu\">#</a> CPU</h3>\n<p>这里感觉要说一下 CPU 的构成，CPU 又称处理器，主要就是有几个构成 ALU，PC，Register，以及 cache。</p>\n<p>从 java 代码出发，到字节码文件，到一条条指令，ok，然后 CPU 负责将一条指令读到 Register 里面，PC 定位读到了哪边，然后 ALU 执行相关的逻辑。因为 cpu 是与内存进行交互的，但是 cpu 很快，读取的速度很慢 1：100；与硬盘差不多 1：一百万。所以就加入了 cache，那么这个 chache 也有很多层级，最常见的就是三层，最慢的就是主存了，这边的话后面再说，为什么要说缓存分层呢，因为一层和二层是在 cpu 里面的。</p>\n<p>这就有了单核双线程的说法，ALU 速度很快，那么每次线程的上下文切换都会将指令以及 PC 信息存起来，然后切换，俗称上下文切换，这个消耗也很大。那么双线程就是说两对 PC+Register，那么只需要让 ALU 换个读就完事了，上下文切换的话，当涉及到两个以上线程再进行。那么为什么不是三个，四个等，估计也是个实验数据，估计多了的话效率应该也不是线性增长的。</p>\n<p>这边还涉及到一个概念就是 CPU 与内存之间的 I/O 叫做总线，锁可以加在总线上。</p>\n<h3 id=\"volatile\"><a class=\"markdownIt-Anchor\" href=\"#volatile\">#</a> volatile</h3>\n<p>这个关键字涉及到很多概念，其中可见性和禁止重排来保证一致性</p>\n",
            "tags": [
                "JUC相关零碎知识点乱写"
            ]
        },
        {
            "id": "http://example.com/2023/10/17/hashmap%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/",
            "url": "http://example.com/2023/10/17/hashmap%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/",
            "title": "hashmap经典面试题",
            "date_published": "2023-10-17T13:09:09.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>因为要面亚信安全，所以看了一下面经，有个问了一堆 hashmap 的问题，刚开始还有点懵，但是查了相关资料之后才发现这些内容都会，只是被问题吓住了。话不多说，直接总结一下</p>\n<h3 id=\"hashmap\"><a class=\"markdownIt-Anchor\" href=\"#hashmap\">#</a> hashmap</h3>\n<p>非常经典的数据结构，基本开发必然是要用到的。</p>\n<p>底层数据结构是 hash 表，也就是所有的类型数据都可以转换为一个二进制数，然后映射到指定长度的数组中。</p>\n<p>经典的就是初始容量 16，扩容因子 0.75，也就是达到容量的 3/4 就开始扩容，扩容是 * 2，都是 2 的次幂。这个有说法，貌似是底层要进行与运算，具体没了解。</p>\n<p>对于 jdk1.7 之前，使用的头插法，但是在多线程触发扩容的时候会出现死循环，后面 1.8 转为尾插法，具体为什么尾插法就可以消除循环连，没什么研究，毕竟多线程建议使用 concurrenthashmap。</p>\n<p>具体为什么会出现循环链，是因为多线程情况下，在 1 执行完 e.next = newtable [i] 后，即将执行 newtable [i] = e 的时候，第二个线程完成了扩容，那么这个时候线程 1 继续往下执行的时候，就会出现修改成循环练的情况，所以 get 的时候就会出现死循环。</p>\n<p>还有就是 hashmap 的 put 过程吧，hash 映射，冲突的话就执行 hash 冲突的算法，hashmap 是链式的，也就是给桶上链表，如果 key 存在的话，就替换 value 值。</p>\n<p>对于线程安全，hashtable 和 concurrenthashmap 都安全，但是基本不怎么用 hahstable，反正我是没用过，hashtable 是不支持 key 和 value 为 null 的，但是 hashmap 可以。</p>\n<p>接下来就说一说 concurrenthashmap，1.7 是使用的 segment 分段锁，segment 继承 reentrantlock，对每一端的访问进行加锁，这应该就是比 hashtable 高效的地方吧，hashtable 是对整个 table 进行上锁的。</p>\n<p>1.8 之后就换成了 cas+synchronized，并且 segment 也取消了，改成了桶上锁，也就是桶可以理解为同一个 hash 值，也就是存放链表的地方，对这个进行加锁，也就是细化了 segment</p>\n<p>对于 cas 的使用我记得是在 put 的时候没有元素的情况下进行 cas 赋初值，如果有值也就是发生 hash 冲突的情况下就转为 synchronized 进行上锁。（对于比较复杂的场景，hash 冲突和扩容，就用 synchronized 进行上锁，其余的用 cas 来解决冲突问题）</p>\n<p>个人理解什么 entry 数组 + segment + 链表，我理解就是对数组的段分为了 segment，其实就是比数组 + 链表多了个 segment 而已</p>\n<p>后面转红黑树，也就是涉及到红黑树的转换情况，将链表转为红黑树的场景要满足两点：1，一条练上的节点 &gt;=8；2，容量大于 &gt;=64；从红黑树退化为链表是元素 &lt;=6</p>\n",
            "tags": [
                "hashmap"
            ]
        },
        {
            "id": "http://example.com/2023/10/16/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/",
            "url": "http://example.com/2023/10/16/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/",
            "title": "SpringBoot自动装配",
            "date_published": "2023-10-16T13:02:59.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>对于 spring boot 的装配或者说启动流程，确实比较复杂，最近了解的内容感觉仅仅只能用作面试的回答。</p>\n<h3 id=\"自动装配\"><a class=\"markdownIt-Anchor\" href=\"#自动装配\">#</a> 自动装配</h3>\n<p>对于 spring boot 而言，最典型的就是 @springbootapplication 这个注解，组合注解，包括主要的三个注解 @springbootconfiguration、@import、componentscan</p>\n<p>@springbootconfiguration 继承 @configuration 注解，也就是将当前类给加载到 context 中（IOC 容器）<br>\n@componentscan 就是表明要扫描的包，也就是所谓的扫描和 application 同级的所在的所有的包中的 bean，来注入。<br>\n@import 才是自动装配的核心注解，其中实现的 autoimportselector，采用 spi 思想，完成第三方 jar 包的自动注入，统一的原则就是加载 META-info 下面的 spring.factory 配置文件（以键值对的方式存储配置），key 是 autoconfiguration 的值会被放到 context 中，然后不停的重复这个过程，直至所有的第三方 jar 包都被加载</p>\n<p>对于 SPI，JDBC 也有用到，主要的思想就是给出一套规定，然后不同的提供者也就是三方去实现，我们只需要引入 jar 包即可，但是如果仅仅是这样，那么程序员仍然要通过 configuration 打入相应的 string，来选择使用哪一个，这就将配置的这个值交给了第三方厂商，让他们在指定位置创建这个配置文件，spi 只需要提供规则，然后去解析，即可。程序员只需要引入 jar 包就完事。</p>\n",
            "tags": [
                "SpringBoot"
            ]
        },
        {
            "id": "http://example.com/2023/10/12/kafka%E7%9B%B8%E5%85%B3/",
            "url": "http://example.com/2023/10/12/kafka%E7%9B%B8%E5%85%B3/",
            "title": "kafka相关",
            "date_published": "2023-10-12T13:06:00.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>对于 kafka，没有使用经验，但是有的面试会问到，水也深，只能记一些理解的<br>\n先上图：<br>\n<img data-src=\"https://pic.imgdb.cn/item/6527f038c458853aef7b1fa7.jpg\" alt=\"\"></p>\n<h3 id=\"构成\"><a class=\"markdownIt-Anchor\" href=\"#构成\">#</a> 构成</h3>\n<p>简单聊一下构成，直接从大的来说，一个 kafka 服务器被称作一个 broker，若干个 broker 组成 kafka 集群；对于内部来说，broker 由若干个 topic 组成，每个 topic 包括若干个 partition，对于消费者来说，可以消费不同的 partition，所以可以支持批量消费，但是对于一个 partition 来说，消费者不能重复消费。</p>\n<h3 id=\"如何保证消费的有序\"><a class=\"markdownIt-Anchor\" href=\"#如何保证消费的有序\">#</a> 如何保证消费的有序</h3>\n<p>kafka 的 partition 中消息的存入是有序的，也就是链表的形式，所以要保证消费的有序，那么生产要生产到指定的分区，并且消费也针对具体的分区；或者就是只使用一个 partition。</p>\n<h3 id=\"如何防止重复消费\"><a class=\"markdownIt-Anchor\" href=\"#如何防止重复消费\">#</a> 如何防止重复消费</h3>\n<p>如果参数设置 auto-commit 为 true 的话，那么 offset 可能会提交不成功，那么就会导致重复消费；所以如果要防止重复消费，这个参数要设置成 false，具体的实现应该是 consumer 自主控制 offset。</p>\n<h3 id=\"如何保证消息不丢失\"><a class=\"markdownIt-Anchor\" href=\"#如何保证消息不丢失\">#</a> 如何保证消息不丢失</h3>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NTk2MTA0MTg=\">https://zhuanlan.zhihu.com/p/459610418</span><br>\n 这篇写挺好的</p>\n<h3 id=\"如何实现高效读写的\"><a class=\"markdownIt-Anchor\" href=\"#如何实现高效读写的\">#</a> 如何实现高效读写的</h3>\n<p>页缓存 page cache（操作系统级的缓存） + 顺序写（通过末尾追加的方式写入数据） + 零拷贝（如果不做任何处理就是磁盘 - os cache - 应用缓存 - socket 缓存 - 网卡发送） 零拷贝就去掉了冗余的拷贝过程，直接让 socket 与网卡交互，socket 缓存了数据的描述，具体的数据直接通过 os cache 发送给网卡</p>\n",
            "tags": [
                "kafka"
            ]
        },
        {
            "id": "http://example.com/2023/10/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/",
            "url": "http://example.com/2023/10/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/",
            "title": "多线程的三大特性",
            "date_published": "2023-10-11T03:49:38.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>深信服面试的时候，面到了多线程的三大特性，虽然多线程这块比较熟悉，但是概念没有对应上，在面试官友好的提示下说了出来，但回想一下确实是自己还没有完全搞明白，不然怎么会对应不上这个简单的概念呢，话不多说，直接开始</p>\n<h3 id=\"多线程的三大特性\"><a class=\"markdownIt-Anchor\" href=\"#多线程的三大特性\">#</a> 多线程的三大特性</h3>\n<p>并不是说起个多线程就一定满足三大特性，只是不满足三大特性会有很多的线程安全问题，那么要消除线程安全，就需要选择性的满足这三大特性，所以其中的点还是蛮灵活的。</p>\n<p>网上都是按照可见性，原子性，顺序性来讲；但是其实这三点并不能完全分隔，只能说概念上可以分割一下</p>\n<p>我起初了解并意识到三大特性的时间还是在了解内存模型的时候，从硬件到 JVM 的内存模型，有个映射关系，具体直接看图<br>\n<img data-src=\"https://pic.imgdb.cn/item/65261d4dc458853aef2d8210.jpg\" alt=\"\"></p>\n<p>这边也有一个可以说的点，我就说的长一点好了：<br>\nCPU 的处理速度和内存的读写速度差距过大，所以在 CPU 和内存之间加入了 CPU 寄存器和 CPU 缓存来提高效率，也就是 SRAM 和 DRAM 的来源了。</p>\n<p>这样的结构对于单线程来说，也就是单核 CPU 来说是完全没问题的。但是多核的发展，给这样的模型带来了困扰，也就是经典的缓存不一致问题，也就是可以想象为数据共享，但是主存中才是真正的共享数据，缓存中是数据副本，所以造成了不一致，因而后面出现了缓存一致性协议，直白点说就是涉及到了同步问题。因而就会出现对于耗时长的指令会到之后面的指令暂停，所以就出现了指令重排序。所谓的指令重拍，并不是乱排，而是让不相干的指令可以不用等待而提前执行。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/65261f17c458853aef33887e.jpg\" alt=\"\"><br>\n这个是线程的执行逻辑，其中与主存打交道交给 JMM 控制，那么具体的映射关系是 thread 中用到的 threadstack 大多存放在缓存中，但是对于 heap 大多存放在主存中，所以对于下层的屏蔽，我们只需要和 threadstack 以及 heap 打交道，而不必与硬件打交道。线程中也是用到了工作内存和主存，感觉和 CPU 缓存以及主存差不多。</p>\n<p>有了上面的内存结构，那么就出现了下面的线程三大特性了：</p>\n<ul>\n<li>可见性，由于内存模型的问题，大致可以分为主存和工作内存，所以多线程工作的时候，对于工作内存中的变量（主存副本），存在不一致的情况。要保证可见那么可以通过 volatile 标记或者 synchronized 关键字或者 lock 来实现。简单说一下加锁和 volatile 的区别，volatile 强制更改后刷新到主存，并且读取 volatile 变量的时候强制从主存中读取。对于加锁而言，修改之后提交到主存，读取的时候需要删除工作内存中的数据，然后从主存中进行读取（其中涉及到了内存 lock 和 unlock 指令）</li>\n<li>原子性，一组要么成功要么失败</li>\n<li>顺序性，主要是要讲一下 happends before 原则。涉及三点主要，实际上跟多，单线程中的总式顺序的，也就是无论指令如何重排，结果肯定与顺序读取的代码是一致的结果；加锁，同一个锁的加锁肯定在解锁之前；volatile 前面的肯定先于后面的</li>\n</ul>\n",
            "tags": [
                "多线程"
            ]
        },
        {
            "id": "http://example.com/2023/10/10/join%E8%A1%A8%E8%BF%9E%E6%8E%A5/",
            "url": "http://example.com/2023/10/10/join%E8%A1%A8%E8%BF%9E%E6%8E%A5/",
            "title": "join表连接",
            "date_published": "2023-10-10T12:35:52.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>表连接，一直就会用个 left join</p>\n<h3 id=\"一张图搞定\"><a class=\"markdownIt-Anchor\" href=\"#一张图搞定\">#</a> 一张图搞定</h3>\n<p><img data-src=\"https://pic.imgdb.cn/item/6525450ac458853aefb43c95.jpg\" alt=\"\"></p>\n",
            "tags": [
                "MySQL"
            ]
        },
        {
            "id": "http://example.com/2023/10/10/SQL%E4%BC%98%E5%8C%96/",
            "url": "http://example.com/2023/10/10/SQL%E4%BC%98%E5%8C%96/",
            "title": "SQL优化",
            "date_published": "2023-10-10T12:06:45.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>对于 sql 的优化，是一个经常会被问到的问题，有一些属于常识性的规范，除去这些的话，可以借助 explain 执行计划来查看具体的情况，从而优化 sql</p>\n<h3 id=\"优化技巧\"><a class=\"markdownIt-Anchor\" href=\"#优化技巧\">#</a> 优化技巧</h3>\n<ul>\n<li>避免使用 select *，最好加上具体的字段</li>\n<li>union 和 union all，union 涉及到了去重处理，所以如果不需要去重最好使用 union all</li>\n<li>exist 和 in，这里体现小表驱动大表的思想，具体的就是 in 内外都可以用到索引，但是 exist 只能内部表用到索引；大表驱动小表是建立在结果集之上的，当外部表很小但是结果集很大的时候，exist 有优势；当外部表大，结果集很小的时候，in 有优势。</li>\n<li>batchInsert 批量插入比 insert 插入多条数据要好，也就是用 sqltemplate 自带的来解决。</li>\n<li>多用 limit</li>\n<li>大数据量分批，对于数据同步这一块，不建议大部分全部直接取出，然后再进行后面的操作，应该使用分批小数据量查询。</li>\n<li>alibaba 开发手册规定，join 的表不应超过三个</li>\n<li>先缩小数据范围再接着后面的操作，比如通过 groupby 来分组，后用 having 限制；没有 where 限制之后在分组效率高（所以能用 where 就不用 having）</li>\n<li>索引优化</li>\n</ul>\n<h3 id=\"索引优化\"><a class=\"markdownIt-Anchor\" href=\"#索引优化\">#</a> 索引优化</h3>\n<p>对于大多数的情况就是索引优化了，优化之前需要先进行判断，是没有建立索引还是索引失效了</p>\n<p>优化的点就是调用 explain 查看执行计划<br>\n导致失效的几个点：</p>\n<ul>\n<li>索引参与运算</li>\n<li>隐式类型转换</li>\n<li>字符串的 % 在前的匹配</li>\n<li>最左匹配原则</li>\n</ul>\n<p>可能还有更多的失效的情况，具体的还要看使用场景</p>\n<p>还有一些情况，比如 or，可以拆分语句好建立使用索引，也就是原先使用 or 达成的效果，通过拆分并且使用 union 或者 union all 来走各自的索引</p>\n<p>对于回表的操作，尽量可以使用覆盖索引，也就是需要的字段涵盖在索引中这是最好的</p>\n<p>对于额外的排序，filesort 最好使用联合索引，也就是索引列和 order by 列并不相同，这也是 filesort 出现的场景，伴随着 order by 出现的</p>\n<p>对于 group by 会出现 using temporary 的情况，创建临时表是比较耗时的，所以最好消去临时表的创建，这个时候就要对照临时表产生的情况进行优化了，具体的情况如下：</p>\n<ol>\n<li>如果 GROUP BY 的列没有索引，产生临时表.</li>\n<li>如果 GROUP BY 时，SELECT 的列不止 GROUP BY 列一个，并且 GROUP BY 的列不是主键，产生临时表.</li>\n<li>如果 GROUP BY 的列有索引，ORDER BY 的列没索引。产生临时表.</li>\n<li>如果 GROUP BY 的列和 ORDER BY 的列不一样，即使都有索引也会产生临时表.</li>\n<li>如果 GROUP BY 或 ORDER BY 的列不是来自 JOIN 语句第一个表。会产生临时表.</li>\n<li>如果 DISTINCT 和 ORDER BY 的列没有索引，产生临时表.</li>\n</ol>\n<p>这边补充讲一下之前对于 explain 的 type 字段的理解：<br>\n对于 index 这个值，说明扫描了全部的索引，比 all 稍微好一点，但是性能也很差<br>\n扫描局部的索引，也就是 range 稍微好一点，这个值基本是可以接受的<br>\n再上面就是 ref const 和 system 了</p>\n",
            "tags": [
                "SQL"
            ]
        },
        {
            "id": "http://example.com/2023/10/10/JDK8%E7%9A%84%E6%94%B9%E5%8A%A8/",
            "url": "http://example.com/2023/10/10/JDK8%E7%9A%84%E6%94%B9%E5%8A%A8/",
            "title": "JDK8的改动",
            "date_published": "2023-10-10T04:03:59.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>这边主要想讲一下具体的新特性，还有就是涉及到 concurrenthashmap 的改动，主要就是 segment 取消了，采用了更细粒度的加锁范围，具体的讲就是锁住了一个具体的 hash 表的节点，也就是数组的一个桶位置。</p>\n<p>具体代码，cas+synchronized</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> V <span class=\"title function_\">putVal</span><span class=\"params\">(K key, V value, <span class=\"type\">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"literal\">null</span> || value == <span class=\"literal\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">hash</span> <span class=\"operator\">=</span> spread(key.hashCode());</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">binCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; f; <span class=\"type\">int</span> n, i, fh;</span><br><span class=\"line\">        <span class=\"comment\">//判断tab是否为null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tab == <span class=\"literal\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            tab = initTable();</span><br><span class=\"line\">        <span class=\"comment\">//数组中当前位置是null就创建一个新的Node，通过CAS写入数组指定位置</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((f = tabAt(tab, i = (n - <span class=\"number\">1</span>) &amp; hash)) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (casTabAt(tab, i, <span class=\"literal\">null</span>,</span><br><span class=\"line\">                         <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>&lt;K,V&gt;(hash, key, value, <span class=\"literal\">null</span>)))</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;                   <span class=\"comment\">// no lock when adding to empty bin</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//当前节点正在扩容</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">            tab = helpTransfer(tab, f);</span><br><span class=\"line\">        <span class=\"comment\">//指定位置不为null</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">V</span> <span class=\"variable\">oldVal</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">//加synchronized 锁</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (f) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class=\"line\">                   <span class=\"comment\">//链表</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fh &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        binCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class=\"line\">                            K ek;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                                ((ek = e.key) == key ||</span><br><span class=\"line\">                                 (ek != <span class=\"literal\">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class=\"line\">                                oldVal = e.val;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                    e.val = value;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            Node&lt;K,V&gt; pred = e;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((e = e.next) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">//尾插法</span></span><br><span class=\"line\">                                pred.next = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class=\"line\">                                                          value, <span class=\"literal\">null</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                   <span class=\"comment\">//红黑树</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> TreeBin) &#123;</span><br><span class=\"line\">                        Node&lt;K,V&gt; p;</span><br><span class=\"line\">                        binCount = <span class=\"number\">2</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class=\"line\">                                                       value)) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                            oldVal = p.val;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                p.val = value;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (binCount != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//大于8转红黑树</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class=\"line\">                    treeifyBin(tab, i);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oldVal != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    addCount(<span class=\"number\">1L</span>, binCount);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出 cas 用在 hashtable 为 null 的时候插入节点时使用，当不为 null 的时候，就对当前桶进行加锁，使用 synchronized 进行操作。</p>\n",
            "tags": [
                "JDK"
            ]
        },
        {
            "id": "http://example.com/2023/10/10/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8GC/",
            "url": "http://example.com/2023/10/10/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8GC/",
            "title": "垃圾回收器GC",
            "date_published": "2023-10-10T02:14:11.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>对于垃圾回收一直是经常碰到，但是基本没系统了解过的点，这段时间其他的点基本解决，系统学习了一下 GC，也不算很底层，这篇博客写的很好<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNTUzOTY5MA==\"> https://zhuanlan.zhihu.com/p/25539690</span></p>\n<h3 id=\"聊一下jvm内存模型\"><a class=\"markdownIt-Anchor\" href=\"#聊一下jvm内存模型\">#</a> 聊一下 JVM 内存模型</h3>\n<p>经典的图<br>\n<img data-src=\"https://pic.imgdb.cn/item/65277181c458853aefbbade5.jpg\" alt=\"\"></p>\n<p>这个是使用元空间替代永久代来作为方法区的实现<br>\n<img data-src=\"https://pic.imgdb.cn/item/652771a3c458853aefbbb19a.jpg\" alt=\"\"><br>\n所以这里也来聊聊我不懂的点，元空间，为什么要用元空间；我觉得既然选择淘汰掉永久代，一定是之前有弊端，后面想出了较为优秀的替代方案。<br>\n感觉主要的就一个点：<br>\n永久代和堆的空间在物理内存上是连续的，也就是说他们仅仅是逻辑上的区分；但是元空间使用本地内存，也就是说当本地内存不超的时候就不会出现 oom。原先的永久代对于类加载过多会导致 oom</p>\n<p>对于永久代中的字符串常量池和静态变量都转移到了堆中<br>\n<img data-src=\"https://pic.imgdb.cn/item/6527d219c458853aef091689.jpg\" alt=\"\"></p>\n<p>目前记录一些想法：<br>\ngc 有很多的类型，minor gc、major gc 和 full gc 这三种吧；但是大部分的 gc 算法并没有实现 major gc，只有 cms 和 g1 是是实现了 major gc。</p>\n<p>网上对于 full gc 的说法众说纷纭，到现在都没整明白。full gc 是对整个堆和方法区进行 gc，minor 是针对年轻代的也就是 edan + s0 或 s1 吧， major 就是老年代，对于 serial, serial old, p new, parallel, parallel old, cms, g1 这么多回收器来说<br>\n serial, p new, parallel 都是针对年轻代的<br>\n serial old, parallel old 都是针对老年代的，都是一整个 stw<br>\n 然而对于 cms 和 g1 来说，是有四个阶段的，初始标记和重复标记需要 stw，并且 g1 的最后一个清理阶段也是要 stw 的，总结来说就是 cms 有两个 stw，但是 g1 有三个。那么为什么说 g1 改进了 cms 呢</p>\n<p>这个也有几点说法，一个就是 g1 的内存不在连续了，而是用的大小相同的区域 region，并且由于使用的是复制删除，所以需要 stw 来进行类的内存整合，但是 cms 用的是标记删除，所以 cms 会有内存碎片的问题，有内存碎片就可能触发 full gc</p>\n<p>这边有了新的理解，也就是对于 cms 和 g1 来说都是 major gc，也就是针对老年代的，但是在 cms 和 g1 触发期间，如果老年代不足了，那么就会触发 full gc，也就是全清，暂时下面先不讲了</p>\n<p>直接说元空间对于永久代的改进，我感觉就是从根本上来说的话，就是元空间实现在了本地内存上，而跟 jvm 内存隔离开来了，网上有说元空间会触发 full gc，我觉得不正确，奶奶的，那特么这个隔离开来还有什么几把用，超，迷惑我一下午，我觉得隔离开来，就不会使用 jvm 那一套回收机制了，而是使用操作系统的一套回收机制，但是 jvm 仍然可以通过参数来限制元空间<br>\n这就显得元空间和永久代的区别很明显了，首先对于 full gc，之前永久代和堆是连续的内存空间，也就是在 jvm 的物理内存中是连续的，属于是逻辑上的隔离，但是这就会对 gc 带来难度，并且永久代中存的是有关类的数据，gc 效率不高，因为回收一个类的条件过于苛刻了。第二个就是内存了，元空间移到了本地内存上面，本地内存多大我多大，可以灵活调整，而不是永久代那样，一旦限定就不好改了，并且也没人能够很准确的估算出给出合适的永久代内存空间，所以，总结下来就两点我认为最重要：</p>\n<ul>\n<li>内存参数的设置可以更灵活了，永久代经常会 oom，但是也不是说元空间不会 oom</li>\n<li>gc 效率更高<br>\n什么其他的为了和 jrocket 整合，感觉不是很重要</li>\n</ul>\n",
            "tags": [
                "JVM"
            ]
        },
        {
            "id": "http://example.com/2023/10/07/IOC%E5%92%8CAOP/",
            "url": "http://example.com/2023/10/07/IOC%E5%92%8CAOP/",
            "title": "IOC和AOP",
            "date_published": "2023-10-07T03:59:35.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>以前也学过，也系统的记录过，但是一个是角度不一样，一个是忘记了。现在就从使用 + 原理，重新记录一下两个核心思想</p>\n<h3 id=\"ioc\"><a class=\"markdownIt-Anchor\" href=\"#ioc\">#</a> IOC</h3>\n<p>控制反转，是一个思想，具体的实现是 DI 依赖注入。<br>\n对于 IOC 思想，几乎处处可见，对于 servlet、监听器、过滤器这些也是 tomcat 通过控制反转创建的，所以 IOC 并不是 spring 特有的</p>\n<p>依赖注入 DI，笼统的来说就是之前通过 new 的现在交给一个叫做 context 的东西来创建，也就是交给了第三方而不是程序员来控制资源的创建。</p>\n<h4 id=\"注入是怎么注入的\"><a class=\"markdownIt-Anchor\" href=\"#注入是怎么注入的\">#</a> 注入，是怎么注入的</h4>\n<p>主要分为 set 注入和构造函数注入，有两种方式：</p>\n<ul>\n<li>xml 文件，主要通过 property 标签和 constructor 标签完成注入，可以添加 autowire 属性，来完成 byname 还是 bytype 注入</li>\n<li>注解，支持注入的注解有 @component、@service、@controller、@repository、@bean、@component 等声明 bean，也就是放到 context 中，使用 @resource、@autowire、@value 等完成注入</li>\n</ul>\n<h4 id=\"实现原理\"><a class=\"markdownIt-Anchor\" href=\"#实现原理\">#</a> 实现原理</h4>\n<p>简单来说就是 map + 反射，用 map 存储唯一 id 以及对应的 bean，通过 id 定位，并通过反射来获取 bean 信息，完成注入</p>\n<h4 id=\"循环依赖\"><a class=\"markdownIt-Anchor\" href=\"#循环依赖\">#</a> 循环依赖</h4>\n<p>这边也就是引入三级缓存解决循环依赖的问题，循环依赖最简单的场景就是 a-b，b-a 有点像死锁的现象，导致出 bug。</p>\n<p>spring 对象产生需要三步骤：</p>\n<ul>\n<li>creatBeanInstance 实例化，也就是调用构造函数</li>\n<li>populateBean 填充属性</li>\n<li>initializeBean 初始化，调用 xml 文件（也就是赋值吧）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实际创建指定的bean。 此时，预创建处理已经发生，</span></span><br><span class=\"line\"><span class=\"comment\"> * 例如 检查&#123;<span class=\"doctag\">@code</span> postProcessBeforeInstantiation&#125;回调。</span></span><br><span class=\"line\"><span class=\"comment\"> * 区分默认bean实例化、使用工厂方法和自动装配构造函数。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> Object <span class=\"title function_\">doCreateBean</span><span class=\"params\">(<span class=\"keyword\">final</span> String beanName, <span class=\"keyword\">final</span> RootBeanDefinition mbd, <span class=\"keyword\">final</span> Object[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Instantiate the bean.</span></span><br><span class=\"line\">    <span class=\"type\">BeanWrapper</span> <span class=\"variable\">instanceWrapper</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instanceWrapper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">    <span class=\"comment\">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class=\"line\">    <span class=\"comment\">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">earlySingletonExposure</span> <span class=\"operator\">=</span> (mbd.isSingleton() &amp;&amp; <span class=\"built_in\">this</span>.allowCircularReferences &amp;&amp;</span><br><span class=\"line\">            isSingletonCurrentlyInCreation(beanName));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (earlySingletonExposure) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">            logger.debug(<span class=\"string\">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class=\"line\">                    <span class=\"string\">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//添加到三级缓存中</span></span><br><span class=\"line\">        addSingletonFactory(beanName, <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Object <span class=\"title function_\">getObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Initialize the bean instance.</span></span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">exposedObject</span> <span class=\"operator\">=</span> bean;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//填充依赖的bean实例。</span></span><br><span class=\"line\">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (exposedObject != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//调用spring xml中的init 方法。</span></span><br><span class=\"line\">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">return</span> exposedObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以循环依赖主要出现在 1，2 阶段。场景如下：</p>\n<ul>\n<li>构造函数中调用其他的 bean，形成 a-b-a 循环依赖</li>\n<li>填充属性的时候调用其他的 bean，形成 a-b-a 循环依赖</li>\n</ul>\n<p>对于循环依赖，spring 引入三级缓存来解决，意思就是执行步骤 1 的时候，将半成品 a 类，放入到三级缓存中，这样如果 a 需要 b，那么就会从三级缓存中以此寻找，1 级（singletonObject）、2 级（earlySingletonObject）、3 级（sigletonFactory）。这样找下来，可以看到，在上述的代码中，步骤一，也就是实例化后，会将这个半成品暴露到三级缓存中，那么 a 去找 b 的时候找不到，但是三级缓存中有 b；反过来，b 去找 a 的时候就找到了，从而解决循环依赖。</p>\n<p>这里有一点就是如果在三级缓存中招到了，并且完成了一个级别之后，对应的缓存中就要删除，上升一个级别。</p>\n<h3 id=\"无法解决的循环依赖\"><a class=\"markdownIt-Anchor\" href=\"#无法解决的循环依赖\">#</a> 无法解决的循环依赖</h3>\n<p>对于无法解决的循环依赖问题，有两个：</p>\n<ul>\n<li>prototype 类型的 bean，因为他们不加入缓存，所以三级缓存策略没有用</li>\n<li>构造函数中的循环依赖，因为三级缓存生效是在实例化之后，所以如果第一步就存在循环依赖，那么是无法解决的。</li>\n</ul>\n<p>对于以上两个场景，都是用延迟加载即可，@lazy 注解，具体的原理目前不是很清楚</p>\n<h3 id=\"aop\"><a class=\"markdownIt-Anchor\" href=\"#aop\">#</a> AOP</h3>\n<p>AOP 也就是切面编程，底层原理使用的是动态代理，说到底还是反射机制</p>\n",
            "tags": [
                "Spring"
            ]
        },
        {
            "id": "http://example.com/2023/10/06/%E7%BA%BF%E7%A8%8B%E6%B1%A0/",
            "url": "http://example.com/2023/10/06/%E7%BA%BF%E7%A8%8B%E6%B1%A0/",
            "title": "线程池",
            "date_published": "2023-10-06T10:39:33.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>线程池算是一个高频的面试点了，除了基础的参数设置之外，还会有一些附加的点，话不多说，总结了一手</p>\n<h3 id=\"线程池的参数\"><a class=\"markdownIt-Anchor\" href=\"#线程池的参数\">#</a> 线程池的参数</h3>\n<p>线程池的参数 7 个，烂熟于心了属于是：</p>\n<ul>\n<li>corePoolSize  核心线程数</li>\n<li>maxPoolSize  最大线程数 = （核心 + 非核心）</li>\n<li>keepAliveTime  存活时间（针对空闲的非核心线程）</li>\n<li>unit  空闲时间的单位</li>\n<li>workQueue 工作的阻塞队列（具体有几个类型，也就是分无限的和有限的，array 和 linked）</li>\n<li>threadFactory  线程工厂（可以添加上线程的前缀，可自定义）</li>\n<li>rejectionPolicy  拒绝策略，有 4 个拒绝策略（1、默认直接抛出异常；2、让主线程去执行，相当于主线程充当了线程池的一员；3、默默丢弃无法执行的线程任务；4、丢弃最早的 oldest，然后当前的加入）</li>\n</ul>\n<p>参数就是上面的七个，可以自定义工厂和拒绝策略<br>\n创建的话，最原始的就是 new ThreadPoolExecutor，然后传入上面的参数<br>\n但是一般不会这么做，基于 spring 或者 springboot，会通过 @configuration 或者 xml 文件，注入线程池，然后直接 @autuwire 注入就行了</p>\n<h3 id=\"如何解决任务丢失问题\"><a class=\"markdownIt-Anchor\" href=\"#如何解决任务丢失问题\">#</a> 如何解决任务丢失问题</h3>\n<p>复杂的任务丢失说实话，感觉有点复杂，这边只讲简单的情况<br>\n从上面可以看出，拒绝策略提供的要么就是异常的抛出，那么是会导致程序中断，或者直接捕捉异常然后落库做记录（这也是一种方法），要么就是丢弃任务，这样就会导致任务丢失，所以如何解决呢？</p>\n<h4 id=\"钩子回调处理\"><a class=\"markdownIt-Anchor\" href=\"#钩子回调处理\">#</a> 钩子回调处理</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CustomThreadPool</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ThreadPoolExecutor</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">CustomThreadPool</span><span class=\"params\">(<span class=\"type\">int</span> corePoolSize, <span class=\"type\">int</span> maximumPoolSize, <span class=\"type\">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">beforeExecute</span><span class=\"params\">(Thread t, Runnable r)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.beforeExecute(t, r);</span><br><span class=\"line\">        <span class=\"comment\">// 在任务执行前进行一些准备操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before executing: &quot;</span> + r.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterExecute</span><span class=\"params\">(Runnable r, Throwable t)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.afterExecute(r, t);</span><br><span class=\"line\">        <span class=\"comment\">// 在任务执行后进行一些清理操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After executing: &quot;</span> + r.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">terminated</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.terminated();</span><br><span class=\"line\">        <span class=\"comment\">// 在线程池终止后执行清理工作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;ThreadPool terminated&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到上面的方法就是继承了 TheadPoolExecutor 线程池，然后可以在任务执行前，执行后和线程池终止后进行一些切面处理；那么这样的话就可以自定义线程池，然后完成任务执行前的一些工作，做落库或者怎么样。这是一种解决方案</p>\n<h4 id=\"重写拒绝策略\"><a class=\"markdownIt-Anchor\" href=\"#重写拒绝策略\">#</a> 重写拒绝策略</h4>\n<p>个人偏向这一点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CustomThreadPool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">corePoolSize</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxPoolSize</span> <span class=\"operator\">=</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">keepAliveTime</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"type\">TimeUnit</span> <span class=\"variable\">unit</span> <span class=\"operator\">=</span> TimeUnit.SECONDS;</span><br><span class=\"line\">        BlockingQueue&lt;Runnable&gt; workQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">RejectedExecutionHandler</span> <span class=\"variable\">rejectionHandler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CustomRejectedExecutionHandler</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">ThreadPoolExecutor</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(corePoolSize, maxPoolSize, keepAliveTime, unit, workQueue, rejectionHandler);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建一个ScheduledThreadPoolExecutor用于处理超时的任务</span></span><br><span class=\"line\">        <span class=\"type\">ScheduledThreadPoolExecutor</span> <span class=\"variable\">timeoutExecutor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ScheduledThreadPoolExecutor</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 提交任务到线程池</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">6</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">Task</span> <span class=\"variable\">task</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Task</span>(<span class=\"string\">&quot;Task &quot;</span> + i);</span><br><span class=\"line\">            executor.submit(task);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 如果任务超时，将任务重新入队</span></span><br><span class=\"line\">            timeoutExecutor.schedule(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (task.isRunning()) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;Task &quot;</span> + task.getName() + <span class=\"string\">&quot; timed out, re-queueing...&quot;</span>);</span><br><span class=\"line\">                    executor.submit(task);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;, <span class=\"number\">5</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 关闭线程池</span></span><br><span class=\"line\">        executor.shutdown();</span><br><span class=\"line\">        timeoutExecutor.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Task</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">running</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Task</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isRunning</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> running;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Task &quot;</span> + name + <span class=\"string\">&quot; is running.&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 模拟任务执行耗时</span></span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            running = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Task &quot;</span> + name + <span class=\"string\">&quot; completed.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CustomRejectedExecutionHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">RejectedExecutionHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Task &quot;</span> + ((Task) r).getName() + <span class=\"string\">&quot; rejected. Re-queuing...&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将被拒绝的任务重新放入队列</span></span><br><span class=\"line\">            executor.getQueue().put(r);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到上面重写了拒绝策略，也就是实现 RejectedExecutionHandler 接口即可，然后重写 rejectedExecution 方法，上面也用另外一个延迟线程池来执行重新入队的操作，大体上感觉没什么问题，也就是对于拒绝的线程我可以记录打印信息，然后重新入队</p>\n<h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>暂时记录这么多，感觉线程池应该问题不大了</p>\n",
            "tags": [
                "Java"
            ]
        },
        {
            "id": "http://example.com/2023/10/06/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E3%80%81bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81thread%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/",
            "url": "http://example.com/2023/10/06/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E3%80%81bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81thread%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/",
            "title": "类加载机制、bean生命周期、thread生命周期",
            "date_published": "2023-10-06T09:45:00.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>原先是只打算写生命周期的，但是看到 bean 的生命周期的时候就联想到了类加载机制，其也有一套跟 bean 很像的生命周期</p>\n<h3 id=\"类加载机制\"><a class=\"markdownIt-Anchor\" href=\"#类加载机制\">#</a> 类加载机制</h3>\n<p>直接上图<br>\n<img data-src=\"https://pic.imgdb.cn/item/6521506bc458853aef6c916d.jpg\" alt=\"\"></p>\n<p>加载也就是加载 class 文件，然后将 class 文件解析成 java 类存放在内存中，包括方法区和栈</p>\n<p>这边说一下方法区，方法区是抽象的概念，1.8 之前的实现是永久代，后面转为原空间了；对于常量池、静态变量等之前存在方法区中，现在存放在堆中</p>\n<p>具体说一下连接阶段干的事：</p>\n<ul>\n<li>验证：加载之后验证一些错误，文件类型，元数据，字节码等等</li>\n<li>准备：主要是给静态变量赋零值</li>\n<li>解析：将符号引用转为直接引用，主要分为静态解析和动态解析，使用 string 来标记引用的类，如果是静态解析，那么在运行时就直接使用地址进行替换 s；如果涉及到多态的话，就是动态解析了，那么会在具体调用的时候才进行 s 的替换</li>\n</ul>\n<p>对于初始化，就是对静态资源和成员变量进行赋值，并不涉及到构造函数</p>\n<p>玛德感觉不是很懂，很牵强，后面再说</p>\n<h3 id=\"类加载器\"><a class=\"markdownIt-Anchor\" href=\"#类加载器\">#</a> 类加载器</h3>\n<p><img data-src=\"https://pic.imgdb.cn/item/652164e8c458853aef77e771.jpg\" alt=\"\"><br>\n类加载器负责的就是将 class 文件装进虚拟机，主要有三类加载器<br>\n bootstrap、ext、以及 system（application） classloader</p>\n<p>说一下这三个负责加载的类：</p>\n<ul>\n<li>bootstrap 负责加载 jre/jre-bin 下面的核心类</li>\n<li>ext 负责加载 jre-bin-ext 下面的扩展类</li>\n<li>system 或者说 app 负责加载我们写的 java 类</li>\n</ul>\n<p>这里说一下如何判断两个类不一样<br>\n首先，全限定名称不同；其次，要被不同的类加载器加载。因为每个类加载器都有自己的命名空间，所以不同加载了那么就是不同，即使全名相同。</p>\n<p>所以出现了双亲委派机制，具体的实现也就是 loadClass 这个方法实现的，如果我们自定义类加载器，也就是继承 classLoader 后，重写 loadClass 方法，那么就会破坏双亲委派机制，可以直接指定我们的自定义 loader 去加载指定的类，但是对于 java 核心的类库是不行的，会报错（网上这么说的，具体没试过，sun 公司对于 JVM 的保护吧）</p>\n<p>正常的 loadClass 有几个步骤：</p>\n<ul>\n<li>查缓存，看看有没有；有的话直接加载</li>\n<li>没有，那么交给上层，也就是双亲去加载，直到最高层也就是 bootstrap</li>\n<li>最后调用 findClass 来加载</li>\n</ul>\n<h4 id=\"破坏双亲委派机制\"><a class=\"markdownIt-Anchor\" href=\"#破坏双亲委派机制\">#</a> 破坏双亲委派机制</h4>\n<p>常见的破坏双亲委派机制的场景，常见的有两个：</p>\n<ul>\n<li>热部署，也就是通过直接加载最新的类，完成热部署，但是这个类名是完全相同的，所以要完成类的加载，那么就需要使用不同的类加载器，所以破坏了唯一加载的原则</li>\n<li>SPI 的实现如 JDBC，也就是核心类需要依靠外部类的情况，典型的就是数据库的加载，不同的厂商依据同一套规则给出不同的实现，那么类加载的时候，到上层 bootstrap 只能加载核心的类，但是核心类依赖外部类的实现（也就是 classpath 下的类），那么这个时候就直接调用线程上下文类加载器完成类的加载。  PS：这边讲一下为什么用线程上下文而不是用 system 直接指定，因为不同的部署环境，他们的类加载器不同，比如 web 等，用的不一定是 system，那么使用线程动态获取，是最合适的。</li>\n</ul>\n<p>这篇讲的很好<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmF6ZWppYW4vYXJ0aWNsZS9kZXRhaWxzLzczNDEzMjky\"> https://blog.csdn.net/javazejian/article/details/73413292</span></p>\n<h3 id=\"bean的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#bean的生命周期\">#</a> Bean 的生命周期</h3>\n<p>对于 bean 的生命周期大致就可以说三个，</p>\n<ul>\n<li>实例化</li>\n<li>填充属性</li>\n<li>初始化</li>\n</ul>\n<p>主要的流程感觉就是加载 xml 或者是注解，然后调用 beanDefinition 反射创建 bean，属性填充，初始化，使用，销毁等等一系列的</p>\n<p>其中涉及到 bean 如果继承了某些类的话，就可以使用钩子来在固定的节点加入一些自定义的处理。例如 aware 就是在属性填充之后，还可以继承 BeanPostProcessor 来在初始化前后进行一些处理</p>\n<p>感觉也就这么多，这边就会涉及到循环依赖吧，按照网上的说法，bean 的实例化包含了 JVM 的一系列过程，感觉是这么回事，，，。</p>\n<h3 id=\"thread的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#thread的生命周期\">#</a> Thread 的生命周期</h3>\n",
            "tags": [
                "Spring",
                "Thread"
            ]
        },
        {
            "id": "http://example.com/2023/10/04/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",
            "url": "http://example.com/2023/10/04/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",
            "title": "Redis数据结构",
            "date_published": "2023-10-04T03:46:39.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>美团面试的时候问到了 Redis 的数据结构，那个时候啥也不懂，所以针对 redis 为什么快，这个数据结构，搞一把。</p>\n<h3 id=\"基本的数据类型\"><a class=\"markdownIt-Anchor\" href=\"#基本的数据类型\">#</a> 基本的数据类型</h3>\n<h3 id=\"底层数据结构\"><a class=\"markdownIt-Anchor\" href=\"#底层数据结构\">#</a> 底层数据结构</h3>\n",
            "tags": [
                "Redis"
            ]
        },
        {
            "id": "http://example.com/2023/10/03/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/",
            "url": "http://example.com/2023/10/03/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/",
            "title": "Redis的持久化",
            "date_published": "2023-10-03T05:35:20.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>关于面试，我觉得持久化这边可以问的点还是挺多的，总的来说就是两个方法 AOF+RDB；然后两者中和，具体怎么中和的可以问，然后流程，涉及到写时复制以及调用 fsync，fork 创建子进程而产生的主线程页表复制等等</p>\n<h3 id=\"aof\"><a class=\"markdownIt-Anchor\" href=\"#aof\">#</a> AOF</h3>\n",
            "tags": [
                "Redis"
            ]
        },
        {
            "id": "http://example.com/2023/09/28/%E5%B9%82%E7%AD%89%E5%AE%9E%E7%8E%B0/",
            "url": "http://example.com/2023/09/28/%E5%B9%82%E7%AD%89%E5%AE%9E%E7%8E%B0/",
            "title": "幂等实现",
            "date_published": "2023-09-28T07:06:03.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>关于幂等的实现，属于是一个高频的面试题吧，所以直接做一个记录，其实这是很大的一块</p>\n<h3 id=\"定义\"><a class=\"markdownIt-Anchor\" href=\"#定义\">#</a> 定义</h3>\n<p>幂等原先用于数学领域，转到计算机就是接口幂等，那么也就是多次请求效果和一次一样。</p>\n<h3 id=\"产生的背景\"><a class=\"markdownIt-Anchor\" href=\"#产生的背景\">#</a> 产生的背景</h3>\n<ul>\n<li>恶意</li>\n<li>客户端重复提交，也就是 button 的问题，表单重复提交</li>\n<li>超时重试，这个背景包括前后端连接超时，前端等待后端结果超时，主要是后者</li>\n<li>重复消费，感觉有点勉强（可说可不说吧，主要是没有用到 mq）</li>\n</ul>\n<h3 id=\"引入幂等的后果\"><a class=\"markdownIt-Anchor\" href=\"#引入幂等的后果\">#</a> 引入幂等的后果</h3>\n<ul>\n<li>增加后端处理逻辑</li>\n<li>将并行改为串行，简单点说就是直接通过单通道限制资源<br>\n所以就是说建议非必要不幂等</li>\n</ul>\n<h3 id=\"幂等的实现方案\"><a class=\"markdownIt-Anchor\" href=\"#幂等的实现方案\">#</a> 幂等的实现方案</h3>\n<p>感觉总的可以分为两大类：</p>\n<ul>\n<li>前端幂等，也叫做接口幂等，通过限制表单或者按钮，或者引入 token</li>\n<li>后端幂等，也叫做服务幂等，主要是和数据库打交道，也就是落库幂等</li>\n</ul>\n<h4 id=\"接口幂等\"><a class=\"markdownIt-Anchor\" href=\"#接口幂等\">#</a> 接口幂等</h4>\n<p>其一，限制表单提交，通过前端限制按钮的重复点击；但是这样的缺点就是可以通过跳过前端直接发起服务器请求来造成恶意破坏。</p>\n<p>其二，PRG，也就是提交表单之后进行页面跳转，防止重复提交并且防止浏览器回退操作</p>\n<p>其三，token，借助 redis；客户端发送请求，服务端给出唯一 token，先落库 redis 还是先给客户端，感觉有说法；然后客户端携带着 token 来第二次请求，请求成功那么执行并删除 token；否则幂等，直接返回。</p>\n<p>建议是先删 token，这样出现的问题就是删除了 token 但是这个时候处理的时候出错了，导致 token 被删了并且业务还没有执行，导致第二个请求进来也处理不了。那么这样是符合幂等场景的，也就是直接出错了，所以重新生成 token，再次请求即可。<br>\n如果先给请求再删 token 的话，如果 token 还没被删掉，第二个请求打进来了，那么就会导致重复请求，有违幂等，除了加上原子操作，那么就是上锁了影响效率。</p>\n<p>token 建议用雪花算法，也就是时间戳 41 位 + 主机 + 随机</p>\n<h4 id=\"服务幂等\"><a class=\"markdownIt-Anchor\" href=\"#服务幂等\">#</a> 服务幂等</h4>\n<p>其一，防重表，通过主键给个防重表，如果重复了，那么返回成功，否则就执行。<br>\n网上有个说法：对于并发大的使用 select 再 insert（这边就要加锁了，因为是两个步骤），对于并发不大的直接使用 insert；个人觉得没什么道理，后面再看。</p>\n<p>使用防重表，主要是为了实现业务和判重分离，其实直接用业务表的主键也是可以的。</p>\n<p>其二，上锁，上锁就有很多的情况，比如通过 mysql、zookeeper、redis 实现分布式锁，mysql 可以乐观悲观锁</p>\n<ul>\n<li>悲观锁，select for update</li>\n<li>乐观锁，加入自增版本号，用 cas 也就是携带着版本号进行 insert；也就是先 select 获取版本号，然后 insert</li>\n<li>分布式锁，可以使用 zookeeper 和 redis。至于 redis 的分布式锁式如何实现的，通过借助 setNX，老版本的 redis 是这样的，目前的 redis 直接通过 set 操作即可，分布式锁上锁过程是原子的，解锁也要保证原子，所以要通过 lua 脚本完成删锁的操作。不然就会造成 expire key 过期，然后误删其他客户端刚创建的分布式锁。</li>\n</ul>\n",
            "tags": [
                "分布式"
            ]
        },
        {
            "id": "http://example.com/2023/09/26/%E8%B7%B3%E8%A1%A8%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91/",
            "url": "http://example.com/2023/09/26/%E8%B7%B3%E8%A1%A8%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91/",
            "title": "跳表和红黑树",
            "date_published": "2023-09-26T13:03:51.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>之前看 hashmap 的时候，研究过红黑树。前段时间同学面携程的时候，面试官给了跳表的八股文，我看到也懵了。翻阅相关资料才知道跳表和红黑树之前还有一定的联系，下面我们来看看。</p>\n<h3 id=\"跳表\"><a class=\"markdownIt-Anchor\" href=\"#跳表\">#</a> 跳表</h3>\n<p><a href=\"https://pic.imgdb.cn/item/6512d769c458853aeff45850.jpg\"><img data-src=\"https://pic.imgdb.cn/item/6512d769c458853aeff45850.jpg\" alt=\"\"></a><br>\n如上图所示，这个就是跳表。</p>\n<ul>\n<li>需要一个有序的链表</li>\n<li>在有序链表之上建立 n/2 个元素，称之为第一层索引，以此类推，最高层两个索引，由此可以推算出高度，从而时间复杂度为 logn</li>\n<li>每个元素都有两个属性，一个 val，一个指向下一个的指针，所以很适合做范围查找</li>\n<li>以空间换时间，这样的话，空间一大，那么代表就是复杂度就下来了，主打的就是一个奢侈。</li>\n</ul>\n<h3 id=\"红黑树\"><a class=\"markdownIt-Anchor\" href=\"#红黑树\">#</a> 红黑树</h3>\n<p><img data-src=\"https://pic.imgdb.cn/item/6512d93bc458853aeff55fdd.jpg\" alt=\"\"><br>\n先来讲一下红黑树的特征</p>\n<ul>\n<li>节点是红色或者黑色</li>\n<li>根节点黑色</li>\n<li>任意一条从根节点到叶子节点路径的黑色节点数量相同</li>\n<li>一条路径不能包含连续的两个红色节点 —》从而可以推出红色节点的父节点必然是黑色</li>\n<li>红黑树中的叶子节点有点不同，他的叶子节点都是 null</li>\n</ul>\n<h4 id=\"红黑树的发展史\"><a class=\"markdownIt-Anchor\" href=\"#红黑树的发展史\">#</a> 红黑树的发展史</h4>\n<p>这也是之前学习的时候了解了一点，这里就简单的总结一下，为什么会发展到红黑树，毕竟一个技术的诞生肯定是有历史的。<br>\n首先就是从数组和链表说起了，众所不周知，数组是查询 O1，链表是删除 O1（当然这里不是说的定位到再删除）。那么除了组合数据结构，就诞生了树结构。如果不限制树的高度，也就是平衡，那么树结构就会退化为链表，所以查询也会退化到 On。后面引入了 AVL，自平衡二叉树。也就是通过自旋的方式来调整树的高度。由于满足平衡二叉树的条件比较苛刻，导致插入数据后的自选频次很高，所以引入了红黑树。红黑树只需要满足一条路径上的黑色节点数相同就行了，所以如果一条全黑，一条间隔红黑，那么最长可以 n/2 不用调整。</p>\n<h4 id=\"红黑树变形\"><a class=\"markdownIt-Anchor\" href=\"#红黑树变形\">#</a> 红黑树变形</h4>\n<p>将红色节点上移到其父节点，那么就会形成 B 树一样的结构，四阶 B 树（节点元素最多为 3 个）</p>\n<h4 id=\"自旋\"><a class=\"markdownIt-Anchor\" href=\"#自旋\">#</a> 自旋</h4>\n<p>些许复杂，后面再搞</p>\n<h3 id=\"跳表和红黑树\"><a class=\"markdownIt-Anchor\" href=\"#跳表和红黑树\">#</a> 跳表和红黑树</h3>\n<p>hashmap 为什么不用跳表？<br>\n我看到一篇博客说的很有道理，就是 hashmap 存在 hash 冲突才用的红黑树存储相同 hash 散列后得元素，所以这个红黑树虽然是有序得，但是要明白一点，跳表得作用场景是范围查找，且需要空间换时间，但是这边散列后的元素其范围查找值我觉得有意义，但是并不完整，因为这里得范围只是冲突后的元素，那么没冲突得元素，但是在范围内得就无法被跳表涵盖进来。</p>\n<p>总的来说，就两点：</p>\n<ul>\n<li>红黑树不占用额外的空间</li>\n<li>hashmap 无序存储，没有范围查找的要求，所以用跳表的话，这个范围查找就没有任何的意义。准确点来说，hashmap 只需要精确查找，通过叶子节点来缩小范围，那么跳表是可以做范围检索的。</li>\n</ul>\n<p>但是总的感觉就是跳表和红黑树其实没差别，说用这个为什么不用那个，感觉有点牵强，你要说用，那么也不是不可以用。</p>\n<h3 id=\"跳表和b树\"><a class=\"markdownIt-Anchor\" href=\"#跳表和b树\">#</a> 跳表和 B + 树</h3>\n<p>也就是 redis 用了跳表，个人感觉，zset 他是要做范围查找的，那么就需要和 B + 树做个横向对比。<br>\n主要的场景就是两个 Redis 和 MySQL。<br>\n对于 B + 树和跳表，如果底层存放相同的数据，那么 B + 树的层级要远小于跳表。这个就要从节点的设计来说吧，B + 树的非叶子节点存放 16k 的信息，可以存放多个节点的信息，但是跳表一个节点一条数据（这边感觉是有说法的）<br>\n我当时的疑问就是为什么跳表不用和 B + 树一样呢，我也整个索引节点存储多个叶子节点信息呗，但是感觉如果这样的话，那么第一就是两个就一样了，还分什么你我；第二就是对于 B + 树这样的设计，其降低层数，那么装入数据的话就是需要修改数据结构，也就是插入的复杂度很高，但是跳表随机插入即可（当然也有不是随机的实现，那个复杂度也不低）</p>\n<p>总而言之就是两点：</p>\n<ul>\n<li>从读取来说，同样的数据如果跳表的抽取间隔不是很大的话，B + 树的层级是远小于跳表的层级的，所以 IO 次数就会少，这对于磁盘读取很重要，但是对于内存读取就可以忽略，因为两者的读取代价完全不同。</li>\n<li>从插入来说，也就是写。B + 树需要调整结构，实现复杂，但是跳表通过随机的节点插入层级，就会很快完成节点的写入，所以 Redis 在选择时，选择实现更为简单且写入效率要高，并且可以忽略读取 IO 的跳表。</li>\n</ul>\n",
            "tags": [
                "数据结构"
            ]
        },
        {
            "id": "http://example.com/2023/09/25/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7/",
            "url": "http://example.com/2023/09/25/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7/",
            "title": "事务的隔离性",
            "date_published": "2023-09-25T09:44:47.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>一直有种面对隔离级别的恐惧，这次看懂了，稍做记录</p>\n<h3 id=\"基本概念\"><a class=\"markdownIt-Anchor\" href=\"#基本概念\">#</a> 基本概念</h3>\n<p>如果是单线程，那么完全不会出现什么问题。直到多线程的出现，就引发了一些列的问题：脏读，不可重复读，幻读。简单解释一下：</p>\n<ul>\n<li>脏读：一个事务读取到了另一个没有提交事务修改过的数据</li>\n<li>不可重复读：一个事务内，两次读取到的同一数据的内容不一样</li>\n<li>幻读：一个事务内，查询符合条件的记录数，两次读到的记录数不一样<br>\n以上的严重性，就是由上到下递减。</li>\n</ul>\n<p>与之对应的有几个隔离级别：</p>\n<ul>\n<li>读未提交</li>\n<li>读已提交</li>\n<li>可重复读</li>\n<li>串行<br>\n innodb 存储引擎，默认的隔离级别是可重复读。<br>\n简单点来说的话就是，读未提交就是读最新数据；读已提交就是可以读到其他事务提交的内容；可重复读就是可以重复读取相同的数据；串行，就是事务挨着事务，加锁了。</li>\n</ul>\n<h3 id=\"read-view和隐藏字段\"><a class=\"markdownIt-Anchor\" href=\"#read-view和隐藏字段\">#</a> Read view 和隐藏字段</h3>\n<p>一条记录有两个隐藏字段：trx_id 和 roll_pointer；分别表示最新修改的事务的 id 和指向 undo_log 中的日志指针。</p>\n<p>read view 说白了就是有关事务 id 的一种数据结构，这里面的主要结构就是四个字段：</p>\n<ul>\n<li>min_trx_id：当前存在的 id 最小的事务（注：事务的 id 是自增长的）</li>\n<li>max_trx_id：下一个事务 id</li>\n<li>m_ids：当前存在的事务 id 列表</li>\n<li>creator_trx_id：创建的事务 id</li>\n</ul>\n<h3 id=\"mvcc多版本并发控制实现\"><a class=\"markdownIt-Anchor\" href=\"#mvcc多版本并发控制实现\">#</a> mvcc（多版本并发控制）实现</h3>\n<p>感觉也没什么高深的，看了才知道就是利用上面的字段来完成的，也就是要明白一些规则。<br>\n注意：这边我刚明白的一点，read view 的创建和事务没有必然的关系，也就是 read view 可以是在事务中创建，也可以在一开始创建也就对应这两种隔离级别，所以 min，max，ids 这几个字段才有了不可替代性。</p>\n<ul>\n<li>对于不活跃的资源我可以改动，也就是小于 min 的。</li>\n<li>对于未创建的我不能改动，也就是大于等于 max 的</li>\n<li>对于之间的，也就要看在不在 ids 中了，也就是这个事务提交了没有。如果我创建 read view 的时候，他提交了，那么我就可以读了。</li>\n</ul>\n<p>看到了哪些可以读，那么就直接读，如果不可以读，就顺着 roll_pointer 链找下去，也就是找之前的记录，来完成当前的事务的隔离。</p>\n",
            "tags": [
                "MySQL"
            ]
        },
        {
            "id": "http://example.com/2023/09/22/%E7%AC%94%E8%AF%95%E9%80%89%E6%8B%A9%E9%A2%98%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/",
            "url": "http://example.com/2023/09/22/%E7%AC%94%E8%AF%95%E9%80%89%E6%8B%A9%E9%A2%98%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/",
            "title": "笔试选择题零散知识点--持续更新",
            "date_published": "2023-09-22T03:28:03.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>主要为了应付选择题一些极其细节的编程问题，还有一些范围很广的概念性问题，话不多说，直接开始</p>\n<h3 id=\"无标题\"><a class=\"markdownIt-Anchor\" href=\"#无标题\">#</a> 无标题</h3>\n<p>1、基础类型的使用：<br>\n必须赋初值，然后使用，不然直接报编译错误，无法通过编译。<br>\n但是引用类型或者数组就不一样，对于 new 的</p>\n<p>2、集合继承图<br>\n<img data-src=\"https://pic.imgdb.cn/item/650d122ac458853aef243cba.png\" alt=\"alt\"><br>\n 这边主要是将 map 记混了，以为都是继承的 collection，然后就是有一些线程安全的集合，vector、hashtable 以及 stack 是继承的 vector</p>\n",
            "tags": [
                "其他"
            ]
        },
        {
            "id": "http://example.com/2023/09/20/Redis%E7%BC%93%E5%AD%98/",
            "url": "http://example.com/2023/09/20/Redis%E7%BC%93%E5%AD%98/",
            "title": "Redis缓存",
            "date_published": "2023-09-20T14:23:45.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>一切都是为了更流利的表达</p>\n<h3 id=\"缓存雪崩-击穿-穿透的定义以及解决方案\"><a class=\"markdownIt-Anchor\" href=\"#缓存雪崩-击穿-穿透的定义以及解决方案\">#</a> 缓存雪崩、击穿、穿透的定义以及解决方案</h3>\n<h3 id=\"缓存同步策略\"><a class=\"markdownIt-Anchor\" href=\"#缓存同步策略\">#</a> 缓存同步策略</h3>\n<h3 id=\"高可用\"><a class=\"markdownIt-Anchor\" href=\"#高可用\">#</a> 高可用</h3>\n",
            "tags": [
                "Redis"
            ]
        },
        {
            "id": "http://example.com/2023/09/20/UF%E5%92%8CKruskal/",
            "url": "http://example.com/2023/09/20/UF%E5%92%8CKruskal/",
            "title": "UF和Kruskal",
            "date_published": "2023-09-20T09:55:31.000Z",
            "content_html": "<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] parent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ufInit</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        parent = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            parent[i] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">union</span><span class=\"params\">(<span class=\"type\">int</span> p, <span class=\"type\">int</span> q)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rootP</span> <span class=\"operator\">=</span> find(p);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rootQ</span> <span class=\"operator\">=</span> find(q);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rootP == rootQ) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        parent[rootP] = rootQ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent[x] != x) &#123;</span><br><span class=\"line\">            parent[x] = find(parent[x]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parent[x];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"comment\">//n is node num, k is edge num</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> sc.nextInt(), k = sc.nextInt();</span><br><span class=\"line\">        <span class=\"type\">Main</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Main</span>();</span><br><span class=\"line\">        m.ufInit(n);</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] edges = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[k][<span class=\"number\">3</span>];</span><br><span class=\"line\">        <span class=\"comment\">//input edge</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">            edges[i][<span class=\"number\">0</span>] = sc.nextInt();</span><br><span class=\"line\">            edges[i][<span class=\"number\">1</span>] = sc.nextInt();</span><br><span class=\"line\">            edges[i][<span class=\"number\">2</span>] = sc.nextInt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(edges, Comparator.comparingInt(a -&gt; a[<span class=\"number\">2</span>]));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span>[] edge : edges) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m.find(edge[<span class=\"number\">0</span>]) == m.find(edge[<span class=\"number\">1</span>])) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            m.union(edge[<span class=\"number\">0</span>], edge[<span class=\"number\">1</span>]);</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            sum += edge[<span class=\"number\">2</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count == n - <span class=\"number\">1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "算法"
            ]
        },
        {
            "id": "http://example.com/2023/09/19/dp%E7%BB%8F%E5%85%B8%E6%A8%A1%E6%9D%BF/",
            "url": "http://example.com/2023/09/19/dp%E7%BB%8F%E5%85%B8%E6%A8%A1%E6%9D%BF/",
            "title": "dp经典模板",
            "date_published": "2023-09-19T07:30:14.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>书接上回。主要写一下 dp 的大体思路，以及背包和股票。</p>\n<h3 id=\"dp思路\"><a class=\"markdownIt-Anchor\" href=\"#dp思路\">#</a> dp 思路</h3>\n<p>场景，涉及到最值，且存在状态转化的，这个时候可以考虑用 dp。当然也不要强行用，如果暴力可以直接 a 的话，就没必要炫技了。</p>\n<p>插一嘴，类似于什么前缀和什么的，感觉就是 dp，无差。</p>\n<h3 id=\"背包\"><a class=\"markdownIt-Anchor\" href=\"#背包\">#</a> 背包</h3>\n<p>直接上代码吧，主要使用一维的 dp 数组来做背包问题</p>\n",
            "tags": [
                "算法"
            ]
        },
        {
            "id": "http://example.com/2023/09/19/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%93%E9%A2%98/",
            "url": "http://example.com/2023/09/19/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%93%E9%A2%98/",
            "title": "算法总结专题",
            "date_published": "2023-09-19T05:56:39.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>最近笔试，有些题量大的，没有给你现场推导或者调试环境，这样的话，有些不熟悉但是很基本的算法，就会浪费很长的时间，以至于送分的拿不到，所以对于一些我自己熟悉的或者不熟悉的都需要整合，以提高速度。</p>\n<h3 id=\"思维风暴\"><a class=\"markdownIt-Anchor\" href=\"#思维风暴\">#</a> 思维风暴</h3>\n<p>也没列什么框架，目前就是打算直接将自己的想法具象化，留痕并且加深印象，话不多说，直接开始。</p>\n<p>对于核心代码模式，没什么可说的，感觉核心代码模式难度可能会上去点，也会涉及到题目给到的数据结构（treenode，listnode 等等），也更偏向于我们平时力扣的 coding 风格，所以会的会，不会的应该也不会了。</p>\n<p>对于 acm 模式，牛客和赛马平台，主要就是在于输入的接收，这个时候要淡定，好的习惯是先接收然后 sout 一下，看一下到底是什么，然后继续解题，比如我第一次做赛马，小米给的输入是 string，需要自己切分来处理数据，没经验，加上自我怀疑，就笔试很不理想。<br>\n对于 acm 来说，我觉得需要注意的就是图和树了，树的话也算是图的一种形式吧，应该以 edge 的方式接收多一点，也就是 int [] 两个节点。图的话需要进一步整合才能做分析，或者直接暴力接收，然后做题，也行，不要畏惧就是了。<br>\n对于图的话，用邻接表接个人觉得好一点，然后就相当于处理一个二维数组，dfs 可以解决，如果超时的话，就需要换图算法了。</p>\n<p>最近打算回顾两类算法，dp 的背包和股票、图的并查集 uf，kruskal，prim 以及 dijkstra</p>\n<p>具体放在下面的 blog 中，冲！</p>\n",
            "tags": [
                "算法"
            ]
        },
        {
            "id": "http://example.com/2023/09/14/%E9%87%8D%E5%86%99equals%E5%92%8Chashcode/",
            "url": "http://example.com/2023/09/14/%E9%87%8D%E5%86%99equals%E5%92%8Chashcode/",
            "title": "重写equals和hashcode",
            "date_published": "2023-09-14T13:33:23.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>一切为了手撕！</p>\n<h3 id=\"话不多说\"><a class=\"markdownIt-Anchor\" href=\"#话不多说\">#</a> 话不多说</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String b;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">char</span>[] c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> == o) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"literal\">null</span> || getClass() != o.getClass()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"type\">Solution</span> <span class=\"variable\">other</span> <span class=\"operator\">=</span> (Solution) o;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a == other.a &amp;&amp; Objects.equals(b, other.b) &amp;&amp; Arrays.equals(c, other.c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> Objects.hash(a, b);</span><br><span class=\"line\">        result = <span class=\"number\">31</span> * result + Arrays.hashCode(c);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实也没啥好讲的，直接从两个函数分开讲吧。</p>\n<p>首先，hashcode 相等，两个对象不一定相等。equals 相等，hashcode 一定要想等。我们一般重写这两个的目的，就是为了去重，合理的判断两个自定义的对象是否相等。</p>\n<p>对于两者要同时重写，更多的感觉就是 hashcode 的重写是为了更快的判断 equals，因为如果 hashcode 都不相同，那么就不用 equals 进行判断了。第二个就是使用 hash，就需要使用 hashcode 来进行散列，所以 hashcode 很关键。</p>\n<h3 id=\"equals\"><a class=\"markdownIt-Anchor\" href=\"#equals\">#</a> equals</h3>\n<p>主要就是四步：<br>\n第一步，看看是否同一对象，是的话还判断啥，直接 true。<br>\n第二步，看看是否为 null，或者所属类是否一样，有一个满足，直接 false。<br>\n第三步，强转，都是同一个类了，直接强转，好进行最后的操作。<br>\n最后，return 直接用 Objects.equals () 或者 Arrays.equals () 来比较，全部用 &amp;&amp; 连接，一个不满足就 false。</p>\n<h3 id=\"hashcode\"><a class=\"markdownIt-Anchor\" href=\"#hashcode\">#</a> hashcode</h3>\n<p>主要还是靠 Objects 和 Arrays 两个工具类，这两个工具类分别针对数组和一般对象，可以直接生成 hashcode。但是如果两个同时存在，需要借助 31 这个特殊的参数，这个参数感觉也是实验数据，也有的解释就是 2^5-1。感觉还是实验获得比较合理一些。<br>\n两者相加即可</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/09/14/Explain%E5%92%8C%E7%B4%A2%E5%BC%95/",
            "url": "http://example.com/2023/09/14/Explain%E5%92%8C%E7%B4%A2%E5%BC%95/",
            "title": "Explain和索引",
            "date_published": "2023-09-14T13:31:27.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>从原先的 “原来还能通过 explain” 查看 sql 的运行效率，到 “请你讲讲 explain 中的各个字段”，再到 “解释一下 extra 字段的值的含义以及效率排序”，一脸懵，不学不行啊，记录一下呗。</p>\n<h3 id=\"explain\"><a class=\"markdownIt-Anchor\" href=\"#explain\">#</a> Explain</h3>\n<p>当需要查看一下当前 sql 在 mysql 中的运行状态时（这个状态包括一些执行时间，是否使用索引，检索的表，检索字段大小）等等，主要还是针对一些其中的字段值，来判断如何进一步优化 sql。</p>\n<p>说实话，explain 很复杂，没太整明白。主要就说一些自己整明白的点吧</p>\n<p>ID：如果存在多个 select 的话，那么 id 就会有多个值，id 值越大，表示优先级越高。</p>\n<p>select_type：查询类型，也就是存在多个 select 的时候，这个时候就会有不同的类型出现，整明白的也就几个吧：</p>\n<ul>\n<li>simple，表示最简单的查询，无嵌套</li>\n<li>primary，最外层的查询</li>\n<li>union，用 union 接的查询；也不是百分百，如果接在子查询里面，那么貌似第一个是 derived</li>\n<li>derived，子查询</li>\n</ul>\n<p>table：查询的表</p>\n<p>type：连接类型，也就是存在级联查询中，下面按照关键字优先级展开简单讲讲每个关键字吧：</p>\n<ul>\n<li>system，个人感觉不太存在，也就是这个表只有一行，emmm 太抽象</li>\n<li>const，针对主键或唯一建的查询，只返回一行，比较好理解</li>\n<li>eq_ref，使用了索引的全部组成，并且索引是主键或者唯一键，也好理解</li>\n<li>ref, 不是很懂，貌似是用到了索引，但是没有主键索引和唯一键索引</li>\n</ul>\n<p>range：范围查询涉及到的字段，关键字貌似就两个 index 和 all，很明显一个用到了索引，另一个全表扫描，如果全表的话，就需要反思一下了</p>\n<p>possible_key 和 key：这两个放一起讲好了，也就是有的索引和用到的索引，没什么好讲的。</p>\n<p>key_len：索引字段长度，没什么好讲的</p>\n<p>rows：估计会扫描的行数，值越小越好</p>\n<p>extra：额外信息，感觉和前面给到的信息有点重，但是可能是针对不同场景的，下面有些字段要说明一下：</p>\n<ul>\n<li>using filesort，文件排序，sql 中包含 order by，然后索引不足以解决 order，那么 mysql 会选择使用内存，超过一定长度就磁盘，这种情况就是这个字段。</li>\n<li>using temporary，临时表，sql 中包含 group by，这个时候索引不足以解决问题，那么就会借助临时表来完成</li>\n<li>using index，使用索引可以解决，</li>\n<li>using where，满足部分的索引，也就是使用了，但没完全使用，比如仅满足</li>\n</ul>\n",
            "tags": [
                "MySQL"
            ]
        },
        {
            "id": "http://example.com/2023/09/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%EF%BC%89/",
            "url": "http://example.com/2023/09/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%EF%BC%89/",
            "title": "设计模式（从代码层面）",
            "date_published": "2023-09-14T13:21:24.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>写这篇也是为了手撕，还有就是加深一下对设计模式的理解吧。</p>\n<p>缘由：得物手撕单例模式，虽然了解之后挺简单的，但是当时就是不会，so</p>\n<h3 id=\"单例模式\"><a class=\"markdownIt-Anchor\" href=\"#单例模式\">#</a> 单例模式</h3>\n<h4 id=\"饿汉模式\"><a class=\"markdownIt-Anchor\" href=\"#饿汉模式\">#</a> 饿汉模式</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">INSTANCE</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总的来说，饿汉模式，就是只要类加载，那么就会有一个单例出现，就像是只要有东西，我就抢一样，“饿汉”—— 很形象。<br>\n那么其中要注意个点，就是将 instance 放在 static 中，让类加载就生成就完事。并且构造函数一定要是私有的，不然外面就可以 new 了。一定要让他们通过 get 获取实例，保证唯一。</p>\n<h4 id=\"懒汉模式\"><a class=\"markdownIt-Anchor\" href=\"#懒汉模式\">#</a> 懒汉模式</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>懒汉模式，也很简单。顾名思义，并不是类加载就给 new 一个，而是当用到的时候才 new 一个，所以它很懒。就是其中引入了 null，判断，然后给 new 或者返回。<br>\n线程不安全，解释一下啊。就是 a，b 同时进入到 if 判断，那么这个时候两个线程同时测到 null，就会同时执行 new。所以就是多个实例，违背了单例，所以线程不安全，也就是存在竞争呗，简单的解决方法就是上锁，synchronized。<br>\n可以给 get 上锁，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span></span><br></pre></td></tr></table></figure>\n<p>也可以给 new 这个代码块上锁，但是代码快上锁有问题，所以就产生了 DCL。上面也有效率问题，也就是每个线程 get 的时候，都要上锁，很慢。</p>\n<h4 id=\"dcl双重锁定检查\"><a class=\"markdownIt-Anchor\" href=\"#dcl双重锁定检查\">#</a> DCL 双重锁定检查</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很经典啊。<br>\n首先，引入 volatile 关键字，虽然我也不动为什么要引入，感觉 static 一样的。<br>\n其次双重判断，如果 null，那么上锁 new，并且如果 a，b 同时进入上锁，那么只有一个能拿到，并且 a 如果拿到，且 new 了；那么 b 就会进入第二层判断，此时不为 null，那么退出，直接拿实例走人。双重保险，很合理。<br>\n第一层判断是为了防止后面的 get 都上锁，加快了速度；第二层上锁，是为了防止重复 new，保证了单例。<br>\n经典。</p>\n<h4 id=\"静态内部类\"><a class=\"markdownIt-Anchor\" href=\"#静态内部类\">#</a> 静态内部类</h4>\n<p>这个我也懂，代码明天更，也就是将 new 放到了里面一层，没什么高深的</p>\n<h4 id=\"枚举\"><a class=\"markdownIt-Anchor\" href=\"#枚举\">#</a> 枚举</h4>\n<p>没整明白，看起来挺叼的</p>\n<h3 id=\"策略模式\"><a class=\"markdownIt-Anchor\" href=\"#策略模式\">#</a> 策略模式</h3>\n<h4 id=\"使用场景\"><a class=\"markdownIt-Anchor\" href=\"#使用场景\">#</a> 使用场景</h4>\n<p>看了一些网上使用策略模式的场景，有一些感悟。<br>\n试想一下有 20 条 if else，此时，需要你来扩展第 21 条，是不是头皮发麻，没错，策略模式可以拯救你。<br>\n所以策略模式就是将业务代码和逻辑代码解耦，方便使用以及扩展。</p>\n<p>具体由三个部分组成 strategy，具体的 strategy 以及策略的使用场景 context</p>\n<p>话不多说，直接上代码</p>\n<h4 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h4>\n<p>主要三块</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// strategy</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">AttackStrategy</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">attack</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// specific strategy</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MeleeAttackStrategy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">AttackStrategy</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">attack</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;近战攻击&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RangedAttackStrategy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">AttackStrategy</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">attack</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;远程攻击&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// context</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Character</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> AttackStrategy attackStrategy;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAttackStrategy</span><span class=\"params\">(AttackStrategy attackStrategy)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.attackStrategy = attackStrategy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">attack</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        attackStrategy.attack();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// use</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Character</span> <span class=\"variable\">character</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Character</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//这一块就相当于之前的if else了，直接交给context来判断</span></span><br><span class=\"line\">        character.setAttackStrategy(<span class=\"keyword\">new</span> <span class=\"title class_\">MeleeAttackStrategy</span>());</span><br><span class=\"line\">        character.attack(); <span class=\"comment\">// 输出：近战攻击</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        character.setAttackStrategy(<span class=\"keyword\">new</span> <span class=\"title class_\">RangedAttackStrategy</span>());</span><br><span class=\"line\">        character.attack(); <span class=\"comment\">// 输出：远程攻击</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"工厂模式\"><a class=\"markdownIt-Anchor\" href=\"#工厂模式\">#</a> 工厂模式</h3>\n<h4 id=\"背景\"><a class=\"markdownIt-Anchor\" href=\"#背景\">#</a> 背景</h4>\n<p>首先说一下为什么要用工厂模式，也就是使用的场景：<br>\n对于我们平时见到的 A a = new A (); 这样的对象创建，我觉得除了说对象的创建和 client 耦合在一起了，其他的感觉用工厂就是脱裤子放屁。<br>\n但是并不是所有的对象创建都是如此的简单的，比如创建一个复杂的对象，需要做一些验证，或者需要很多的参数等等，那么这个时候就会很麻烦。应用到现实生活中就是，对于简单的小玩意，我可以自己搞搞，然后用。但是对于汽车，飞机，我只是想用一用，你让我自己去造，不开玩笑么，所以交给工厂就好。</p>\n<p>现在说一下工厂模式的意义，</p>\n<ul>\n<li>解耦，解什么耦，创建和使用的耦合，我只关心使用，而不关心创建</li>\n<li>解耦就会导致什么，代码复用麻，所以就避免了多次创建的冗余的代码</li>\n</ul>\n<p>感觉主要就这两点吧，其余的没啥好说的。</p>\n<h4 id=\"代码实现-2\"><a class=\"markdownIt-Anchor\" href=\"#代码实现-2\">#</a> 代码实现</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如果让我手撕的话，那么主要就是工厂类和产品类，两个都要接口或者说抽象类；然后工厂类有A B，产品类有a b；工厂A能成产a b，工厂B也能生产a b；感觉就是有点像抽象工厂</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//factory</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Factory</span> &#123;</span><br><span class=\"line\">\tPhoneProject <span class=\"title function_\">projectPhone</span><span class=\"params\">()</span>;</span><br><span class=\"line\">\tLaptopProject <span class=\"title function_\">projectLaptop</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//specific factory</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HuaWeiFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Factory</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> PhoneProject <span class=\"title function_\">projectPhone</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HuaWeiPhone</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> LaptopProject <span class=\"title function_\">projectLaptop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HuaWeiLaptop</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XiaomiFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Factory</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> PhoneProject <span class=\"title function_\">projectPhone</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XiaomiPhone</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> LaptopProject <span class=\"title function_\">projectLaptop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XiaomiLaptop</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//此处省略产品的接口和实现类</span></span><br><span class=\"line\">。。。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">PhoneProject</span> <span class=\"variable\">huawei</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HuaWeiFactory</span>().projectPhone();</span><br><span class=\"line\">\t\thuawei.printInfo();</span><br><span class=\"line\">\t\thuawei.getId();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"type\">PhoneProject</span> <span class=\"variable\">xiaomi</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XiaomiFactory</span>().projectPhone();</span><br><span class=\"line\">\t\txiaomi.printInfo();</span><br><span class=\"line\">\t\t<span class=\"type\">LaptopProject</span> <span class=\"variable\">huawei1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HuaWeiFactory</span>().projectLaptop();</span><br><span class=\"line\">\t\thuawei1.printInfo();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结一下上面的代码，总的来说也没什么高深的，也就是将 factory 抽象了一下，然后有几个工厂实现类，调 produce 生产产品；感觉就是这样。</p>\n<h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>目前感觉掌握了这几个设计模式吧，其实也没那么高深；<br>\n最好理解的当然是单例了，也就是防止对象被多次创建，spring 里面就是限制了单例，会个 DCL 感觉就差不多了。<br>\n对于策略和工厂的话，总感觉很相似，但是也就是实现的思路其实差不多的，都是解耦，然后使用的话也是让策略或者工厂去选择。<br>\n从具体的目的使用来说的话，两者区别还是很大的</p>\n<ul>\n<li>对于策略来说，主要解耦的是逻辑代码和业务代码。其目的是为了给出策略，也就是选择。它主要的三个 strategy，impl 和 context。也就是抽象实现，但是具体的再 context 里面吧，通过对象传进来然后赋值给抽象 strategy，后面直接用 context 来调方法，完成逻辑解耦。</li>\n<li>对于工厂来说，主要解耦的是对象的创建和使用。其属于创建型设计模式。主要的也就是 factory，impl；product，impl；只要有工厂的实例，或者静态类，就直接可以创建一些复杂对象，完成解耦。</li>\n</ul>\n<p>感觉也没什么复杂的，放宽心。</p>\n",
            "tags": [
                "设计模式"
            ]
        },
        {
            "id": "http://example.com/2023/09/14/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/",
            "url": "http://example.com/2023/09/14/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/",
            "title": "常见排序总结（为了手撕）",
            "date_published": "2023-09-14T12:58:06.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>总结一下常见的排序，主要以记录为主。排版就直接上代码 + 个人理解的思路。并且是本人习惯的编码风格。主要是为了防止手撕遇到，不然真不想总结这玩意…</p>\n<h3 id=\"冒泡\"><a class=\"markdownIt-Anchor\" href=\"#冒泡\">#</a> 冒泡</h3>\n<p>冒泡不打算上代码，直接讲个思路。<br>\n两层 for，以升序为例，每轮选最小的放前面，或者最大的放后面。<br>\n两两相邻比较，大的往后移即可。</p>\n<h3 id=\"选择\"><a class=\"markdownIt-Anchor\" href=\"#选择\">#</a> 选择</h3>\n<p>选择也一样不上代码，跟冒泡类似，只不过冒泡是每次都 swap，而选择是以 temp 记录每一轮的最大数，然后最后进行 swap 即可</p>\n<h3 id=\"快排\"><a class=\"markdownIt-Anchor\" href=\"#快排\">#</a> 快排</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">quicksort</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left &gt;= right) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        swap(nums, random.nextInt(right-left+<span class=\"number\">1</span>)+left, left);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sentinel</span> <span class=\"operator\">=</span> partition(nums,left, right);</span><br><span class=\"line\">        quicksort(nums,left, sentinel -<span class=\"number\">1</span>);</span><br><span class=\"line\">        quicksort(nums, sentinel +<span class=\"number\">1</span>, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">partition</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> left;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= nums[temp]) right--;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= nums[temp]) left++;</span><br><span class=\"line\">            swap(nums,left, right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(nums, temp, right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> nums[left];</span><br><span class=\"line\">        nums[left] = nums[right];</span><br><span class=\"line\">        nums[right] = temp;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码是加入了 random 的写法，目的是防止了一些极端的情况。说一下思路</p>\n<p>选择一个基准的 num，然后对左右两边再进行快排，明显是个分治（递归）。</p>\n<p>那么就是这个基准如何去找，单独拉出一个 partition 函数，以最左边的 num 为基准，左右两个指针 left 和 right 同时找小于等于和大于等于他的。注意，这里的等于要带上，不然会死循环，也就是 left 和 right 会不往中间走。需要注意的点就是 right 在前，不然会出现最终的位置错误。</p>\n<p>最后替换的那个 num 就是后续的切分点。</p>\n<h3 id=\"插入排序\"><a class=\"markdownIt-Anchor\" href=\"#插入排序\">#</a> 插入排序</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">InsertSort</span><span class=\"params\">(<span class=\"type\">int</span> arr[])</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; len; i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> arr[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> j;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = i-<span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j] &gt; tmp)&#123;</span><br><span class=\"line\">               arr[j+<span class=\"number\">1</span>] = arr[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[j+<span class=\"number\">1</span>] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>网上找的代码，具体没写过，直接说一下思路。</p>\n<p>插入的思想就是跟打牌抓牌，然后整理牌一样。</p>\n<p>两层 for，第一层相当于抽牌。第二层相当于找插入点。具体的思路就是将当前的牌的位置空出来，用 temp 接一下，升序的话就是大于当前牌的 num 往后移，否则退出循环，将 temp 插入到退出的那个点即可。</p>\n<p>优化：也就是利用的插入的特点吧，手里的牌必然是有序的，所以查找插入点可以用二分，所以会进一步降低复杂度。</p>\n<h3 id=\"希尔排序\"><a class=\"markdownIt-Anchor\" href=\"#希尔排序\">#</a> 希尔排序</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">shellSort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr == <span class=\"literal\">null</span> || arr.length &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">gap</span> <span class=\"operator\">=</span> arr.length / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (gap != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> arr[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i - gap;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; value; j -= gap) &#123;</span><br><span class=\"line\">                arr[j + gap] = arr[j]; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr[j + gap] = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        gap /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>网上考的代码，具体我也没写过。说一下具体的思路。</p>\n<p>大体的思路就是，分组进行插入排序，通过不断的缩小这个分组的长度来达到整体的排序效果。</p>\n<p>编码的思路和实际的讲解思路稍微有点不一样。讲解思路是对每一组进行插入排序，但是编码的思路是每次仅完成每一组的一个元素的位置寻找。说的形象一点就是，当前如果是第一组的第二个元素插入，那么 i 的下一轮就是第二组的第二个元素的插入，所以稍微有点不一样，看代码就知道了 i++，插入的话，j 是 j-gap 跳着找。没有图还是比较抽象，，，</p>\n<h3 id=\"堆排\"><a class=\"markdownIt-Anchor\" href=\"#堆排\">#</a> 堆排</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">heapsort</span><span class=\"params\">(<span class=\"type\">int</span> n[])</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> n.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">        buildHeap(n, i);</span><br><span class=\"line\">        swap(n, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buildHeap</span><span class=\"params\">(<span class=\"type\">int</span> n[], <span class=\"type\">int</span> end)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> end + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> len / <span class=\"number\">2</span> - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> <span class=\"number\">2</span> * i + <span class=\"number\">1</span>, r = l + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> l;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r &lt;= len - <span class=\"number\">1</span> &amp;&amp; n[l] &lt; n[r]) &#123;</span><br><span class=\"line\">            p = r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n[i] &lt; n[p]) &#123;</span><br><span class=\"line\">            swap(n, i, p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接贴的网上的代码，应该是教科书代码。具体的思路如下：</p>\n<p>堆排的最直观的思路是，加入是大顶堆，每次能取到最大的元素，将这个最大的元素摆放在最后的位置即可，重点在于怎么写这个大顶堆，这边看的时候也是刷新了一下思维。</p>\n<p>一直以为像堆这种的树结构，都是 treenode 节点，通过指针来跳的，但是那样的话就会很难写。以前一直不知道这个堆该怎么手撕，现在看上面的代码。</p>\n<p>heapsort 是整体的结构，每次取 i-n 的元素进行重新的堆排，而排好的，也就是堆顶，放到末尾。</p>\n<p>buildheap 就是如何调整这个堆的，很神奇。这边有一些我认为的先验知识，首先堆的起始点是 n/2，因为是完全二叉树，所以有子节点的最后一个节点必然是 n/2 的位置。其次如果当前节点为 i ，那么其子节点就是 2i 和 2i+1，所以将 i 和 2i 与 2i+1 比较，找出最大的然后 swap 即可（注意：上面的代码是从 0 下标开始的，也就是没有做处理，我看有的讲解是将第一个位置空出来，然后下标就可以和我上面的对上；但是上面的代码更实际，也就是统一 -1）</p>\n<p>​\t上面这个 buildheap 代码思路，就是判断是否有右子树，有的话，标出大的那个，如果根节点小于大的那个，那么就换上去，依次类推，十分简单，堆就构造完了。</p>\n<h3 id=\"归并排序\"><a class=\"markdownIt-Anchor\" href=\"#归并排序\">#</a> 归并排序</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span>[] sortArray(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(left == right) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;nums[left]&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> merge(sortArray(nums,left,mid),sortArray(nums,mid+<span class=\"number\">1</span>,right));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span>[] merge(<span class=\"type\">int</span>[] leftArr, <span class=\"type\">int</span>[] rightArr)&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[leftArr.length + rightArr.length];</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, right = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; res.length; i ++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left &gt;= leftArr.length) res[i] = rightArr[right++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(right &gt;= rightArr.length) res[i] = leftArr[left++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(leftArr[left] &lt; rightArr[right]) res[i] = leftArr[left++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> res[i] = rightArr[right++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分治思想，有点和快排类似，但是归并比快排更稳定，也就是当纯倒序，快排会退化成 O (n^2)。</p>\n<p>这是之前写的代码，也就是一贯的风格，用 int [] 来接，并且用 split 和 merge 两个组成归并排序。</p>\n<p>大体的思路就是不停的切，每次找 num 的 mid，切开；left 到 mid，mid+1 到 right；也很简单，split 不用说了，就是找 mid，切开；merge 的话就是合并两个有序的数组，很简单。</p>\n<h3 id=\"基数排序\"><a class=\"markdownIt-Anchor\" href=\"#基数排序\">#</a> 基数排序</h3>\n<p>简单说一下，并没有细看<br>\n说使用的桶思想，每一轮使得每一位有序。</p>\n<h3 id=\"稳定性\"><a class=\"markdownIt-Anchor\" href=\"#稳定性\">#</a> 稳定性</h3>\n<p>这边讲一下稳定性，稳定性的意思并不是最好和最坏的时间复杂度一样，而是对于相同的两个元素，排完序后他们的相对位置总是保持不变的。<br>\n所以基于上面的定义，那么稳定的排序算法不会改变相同元素的相对位置。直接给结论，不稳定的排序算法有：</p>\n<ul>\n<li>快排，sentinel 的选择</li>\n<li>选择</li>\n<li>堆</li>\n<li>希尔</li>\n</ul>\n<h3 id=\"空间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#空间复杂度\">#</a> 空间复杂度</h3>\n<p>也没有细看，目前就直接记不是 O (1) 的算法：</p>\n<ul>\n<li>快排</li>\n<li>归并</li>\n<li>基数、桶、计数（三个桶都是 n+k）</li>\n</ul>\n<h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>以上就是我接触的常见的排序了，感觉也是了结了一个心事。其中常写的就是快排和归并，总结一下就是很简单，也就这两个我贴的我自己的代码风格。</p>\n<p>欧凯，结束，排序了结，希望手撕到这种题目的时候我可以秒斯，yes</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/09/14/%E8%AE%A9%E8%87%AA%E5%B7%B1%E6%85%A2%E4%B8%8B%E6%9D%A5/",
            "url": "http://example.com/2023/09/14/%E8%AE%A9%E8%87%AA%E5%B7%B1%E6%85%A2%E4%B8%8B%E6%9D%A5/",
            "title": "让自己慢下来",
            "date_published": "2023-09-14T11:10:06.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>工作难找，* 难吃，欸</p>\n<h3 id=\"新阶段\"><a class=\"markdownIt-Anchor\" href=\"#新阶段\">#</a> 新阶段</h3>\n<p>所谓厚积薄发，书到用时方恨少。所以，在大火都着急 offer 的时候，我打算稳住自己的节奏，缓步推进学习计划。<br>\n俗话说的好，最大的敌人就是你自己。不能自乱阵脚，只要我在进步，那么总有接近目标的一天，yes</p>\n<h3 id=\"计划\"><a class=\"markdownIt-Anchor\" href=\"#计划\">#</a> 计划</h3>\n<p>频繁且少量的更新自己的知识点，虽然网上都有，但这也就是类似于默写吧，加深记忆。<br>\n自己的理解，所以可能有错误。<br>\npeace &amp; love</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/18/%E5%AE%9E%E4%B9%A0%E6%B1%87%E6%80%BB/",
            "url": "http://example.com/2023/07/18/%E5%AE%9E%E4%B9%A0%E6%B1%87%E6%80%BB/",
            "title": "实习汇总",
            "date_published": "2023-07-18T11:10:06.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>本篇是技术文。<br>\n实习以来，接触了很多的东西，下面从几个方面简单罗列一下：</p>\n<ul>\n<li>语言：Java、Python</li>\n<li>框架：SpringBoot、Hibernate、Mybatis、Django</li>\n<li>数据：MySQL、Milvus、ElasticSearch、Ceph<br>\nPS：Ceph 分布式存储，我不知道应不应该这么分类，在公司的具体的用法就是通过 Swift/S3，与分布式存储系统进行交互，具体的业务就接触过上传附件。还有很多其他的东西，我不知道该怎么分类，我想把他们分为工具的，但是总感觉不合适，可能是因为没弄懂，确实是没弄懂，后面单独讲。</li>\n</ul>\n<h3 id=\"粗略的过一下\"><a class=\"markdownIt-Anchor\" href=\"#粗略的过一下\">#</a> 粗略的过一下</h3>\n<p>这篇我没有详细的框架，但是有个很明确的想法（串一下目前接触到的技术），所以肯定全部是略讲。<br>\n串的话，我主要打算按照时间线来，回顾一下两个月接触到的各种工具、技术…</p>\n<h4 id=\"单元测试\"><a class=\"markdownIt-Anchor\" href=\"#单元测试\">#</a> 单元测试</h4>\n<p>刚开始来的时候，我主要是写 Junit 来熟悉组内接手的业务，这边先是写的 Java 项目的单元测试，后面又写了 Python 的单元测试。<br>\n对于 Java 而言，组内使用的框架是 Junit+PowerMockito。这边讲一下单元测试主要的思想：检验代码逻辑，按照软件工程的概念，就是对于业务代码的测试，也属于最底层的测试了，所以一般是由程序员编写测试用例。组内使用的框架是 Junit+PowerMockito，感觉主要的还是 mock，也就是所谓的打桩（模拟）。通过模拟当前程序之外的对象 / 函数，来检验逻辑的正确性。Java 主要就是通过 PowerMockito 来模拟对象，以及对象的行为。其中印象比较深刻的点在于可变参数方法的 mock、多线程 mock 以及有无返回值方法的 mock，其他的感觉都是一些正常的 mock。<br>\n对于 Python 而言，和 Java 对应的话，就是 TestCase+mock。接触的 Junit 是基于 Django 写的后端的前台管理，使用的是 Django 内部的 TestCase+Python 的 Patch+MagicMock。测试类继承 TestCase，使用 @patch 来模拟方法以及 MagicMock 来模拟对象。@patch 相当于注入，MagicMock 相当于 new，可以简单的这么理解。其中印象深刻的点在于，@patch 注入和方法中的参数是相反的（这边描述的很抽象，我也没截图，大概只有我自己能看懂）、需要额外定义 side_effect 函数，并且传给 mock 对象的 side_effect 属性，来模拟对象的行为、Python 中比较抽象的在于它 @patch 传入方法不是对象，这个 Java 相比还是很大区别的，当时也被坑了好久，其他的感觉也就正常吧，主要是和 Java 有很多不一样的点。<br>\nPS：其中对于测试用例的书写，大致是通过数据库表结构或者代码中用到的属性来 mock；正规是要最后使用 assert 来断言，但是我目前还没体会到这个 assert 的作用，总感觉不好用；不太科学的衡量标准，检测当前 UT 的标准是覆盖率。</p>\n<h4 id=\"项目开发\"><a class=\"markdownIt-Anchor\" href=\"#项目开发\">#</a> 项目开发</h4>\n<p>其一，完整的项目开发就是公司提供的 MIT，针对校招生的开发实践，目的主要是为了熟悉公司的工具和框架吧。<br>\n这个项目非常的完整，从 0 开始，需要申请 App ID，走公司的流水线平台。这个 App ID 就是公司识别项目的唯一标志。流水线的话，可以理解为一条龙吧，主要是 CI/CD（持续集成）。这边有很多的概念，我主要讲一下这流水线中涉及到的东西吧。将 Git 与 CI/CD 工具关联（公司平台做了），当 push 的时候，自动生成对应的镜像，平台可以配置集群（针对项目，也就是项目可以部署在多个服务器上，可以做一些访问限制以及负载均衡），很多功能，更多的是作为一个工具，这个平台也就是将项目开发部署和维护都交给程序员了，这也是 CI/CD 的核心理念吧。申请 App ID 之后，就相当于有了一个通行证吧，然后通过公司的脚手架创建 SpringBoot Web 项目。通过脚手架创建的好处，就是公司内部的一些默认配置会给你设定好。这边就涉及到公司使用的 BOM（写在 POM 中，公司内部的 Jar 包版本管理，原理没有了解过），其作用相当于<dependencyManagement>，后续使用公司内部的 Jar 包就不需要指定版本了，也避免了一些版本冲突。从数据说起的话，就是题目提供的 mysql 和 Redis，两个都是公司建好的集群（公司内部一般数据都是统一化管理，并且封装一层访问方式，为了避免密码的配置）。公司通过 DAL（应该是公司内部封装的 mysql 的连接方式）建立与 mysql 的数据连接，Redis 的话是直接调的公司的 Jar 包。当然要配置 SqlSession，也就是这边深刻理解了 bean 的注入，对于以上两者都需要进行 config 的注入，将数据连接交给 spring 管理。Redis 比较简单的使用，mysql 的话，还需要使用 JPA 规范，这里使用的是 Mybatis Plus，这边深刻理解了 Mybatis Plus 对于 SqlSession 的封装注入，与 Mybatis 还是不一样的。然后就是做一些基础的 CRUD 了。<br>\n除了基本的业务之外，这里面增加了很多其他的东西：QMQ 消息的收发（公司内部也封装了消息中间件，个人感觉就是集群化了）。通过 Baiji 规范写 SOA 服务，并且发到公司内部的 SOA 平台上，通过 Client 实现并调用（跟 Jar 包一样）。VI 点火，也就是项目启动的时候，需要验证是否满足项目启动的标准，当然可以在项目启动之前做一些操作，比如资源的加载什么的。重量级的就是 log 埋点了，出 bug 才知道日志的重要性。所以公司有很多关于日志的平台 CLog、Cat、Dashboard…，公司内部封装很多工具，将 @slf4j 生成的 log 直接上传到 log 管理平台，提供日志分析等等。深刻体会日志埋点的重要性。<br>\nPS：这个学到了很多的东西，除去熟悉了公司的工具和技术架构之外，从头到尾捋顺了项目的开发。建立了一个比较规范的包结构。深入理解了对象注入。</p>\n<p>其二，非完整项目开发，也就是对已有项目修改，或者开发一些新的接口。<br>\n第一个场景是合并带有时间戳的数据库记录，类似于交并集的算法题。说的专业点的话，就是先 sort，使用贪心进行记录的合并。基本和算法题一模一样，只是涉及了一点业务背景，其中涉及到对象解包，也就是将内部封装好的 DTO 对象，通过 BeanUtil 拆解为 map 集合，然后再添加一些新的键值对，返回给前端。上次用的 apache 的 BeanUtil，但是建议貌似使用 mapstruct 比较好一点。第二个场景与 ElasticSearch 相关，其实需求很简单，就是根据用户当前的状态信息，筛选 es 上的数据。了解了 es 的数据结构，一如既往，对于数据库而言，肯定有配套的语句，而最难的肯定是 select。对于 es 也一样，我大部分经历也是在学习它的语法，后面会有专门的文章来分享一下 es，从搭建到检索。这个项目并没有使用目前现有的工具，历史原因吧可能，直接使用的 template 模板文件来生成语句（这边提一嘴，这也就是底层吧，比如使用其他的工具的时候，就是对于这个模板语句的生成做了封装），这边学到的点就是对于 freemarker 这类的模板工具有了深刻的理解，后面也打算深入学习一下，然后搞一篇。第三个场景是附件上传，这边接触到了 Ceph，两类访问方式吧（Swift 和 S3），目前只知道这是个分布式的存储系统，实现的话也是通过 Swift/S3 连接服务器，然后上传的话，直接返回一个 URL，可以直接以 get 方式下载资源。实现也很简单吧，但是里面的东西还是很多的。一个是了解了 Session 和 Cookie，因为 Session 是服务端加工的，一般要 setAttribute，所以对于 controller 拿数据的时候，@requstParam 和 @requestAttribute 还是不一样的，细品，反正我经过这个接口直接深入体会。还有的话就是这里的一个工程性的点，一般对于这个需求的话，我直接上传返回 URL 直接就结束了，但是我从佳文那里学到的点就是，本地需要建立一张附件信息表，记录上传的附件信息，是不是很有必要！</p>\n<h4 id=\"结尾\"><a class=\"markdownIt-Anchor\" href=\"#结尾\">#</a> 结尾</h4>\n<p>说实话，真的很难写。<br>\n一个是我的语言表达一向有很大的问题，二者确实脑子现在很混乱，有很多就没有理清楚…<br>\n 所以我也就抱着记录一下的心态来写，主要是记录一下涉及到的知识点吧，后面理清楚一点再重新写这篇，并且其中也埋下了很多技术坑，不知道有生之年能不能填上。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/15/%E7%95%85%E6%83%B3/",
            "url": "http://example.com/2023/07/15/%E7%95%85%E6%83%B3/",
            "title": "畅想",
            "date_published": "2023-07-15T08:38:28.000Z",
            "content_html": "<p><img data-src=\"https://i.imgtg.com/2023/07/15/OzdvOt.png\" alt=\"Alt Text\"></p>\n<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<blockquote><p>天不生我大白鹅，画界万股如长夜！</p>\n<footer><strong>——毕加索</strong></footer></blockquote>\n<p>咳咳，如大家所见，鄙人走的抽象派…<br>\n 今天我们就来纸上谈兵一手，分析一下，如何靠的一张嘴，搭建一个前后端系统。</p>\n<h3 id=\"系统架构\"><a class=\"markdownIt-Anchor\" href=\"#系统架构\">#</a> 系统架构</h3>\n<p>先是自身的想法，我想将这个静态的博客，搭建成一个前后端分离的博客系统。为什么这么想呢，主要有几个原因：<br>\n其一，实习学到的一点技能，想找个地方挥霍一把。<br>\n其二，就想拆一下这个 hexo 搭建的静态 page<br>\n 其三，很主要的原因，主要是不想写论文，找点喜欢的事做做…</p>\n<p>可以从图上得知，本人的画技如此的滑稽…，<br>\n可以从上图得知，我想将 Hexo 作为一个只生成博客的空壳，将数据从里面分离出来，持久化到 mysql，然后通过后端的 API，将数据返回给前端，这样就前后端分离了。那么能不能有个发布博客的后台呢，以及统计一些数据、展示图表的后台呢，我觉得可以有，这样直接就可以线上，可以线下了，岂不美滋滋。</p>\n<p>大体而言，外面能看到的，也就是域名能够访问到的，当然还是和之前一样，只有博客。我目前还没有完全想好这个博客是不是要动态资源，还是直接用前端的技术来做检索，并且还将资源直接以静态的方式存储在服务器上。然后备份一份（所谓的持久化到 mysql），给后端做处理，在后台管理页面也能展示不一样的东西。因为如果这样做的话，有几个优势吧：<br>\n其一，消耗的资源小，并且静态的博客也可以完全用之前的一套，少消耗点精力，再者我不用另外租服务器了<br>\n其二，这本来就没打算给外界访问，所以后台做线下处理很符合我的需求，但是就是需要手动同步数据，就很无语，不知道有什么什么其他的好方法。</p>\n<p>但是思来想去，还是觉得前后端分离要高大上一点，也就是有违博客的初衷了。</p>\n<h3 id=\"小麻烦\"><a class=\"markdownIt-Anchor\" href=\"#小麻烦\">#</a> 小麻烦</h3>\n<p>唉，直接叹气，md<br>\n 简直对前端一窍不通，主要是感觉之前学的 vue，以及一些基础的 html，css，js。到如今这个封装的不像样的年代，总感觉中间搁着好多层，就好比后端，springboot 和原生的 java 也搁着好多层，但是熟悉的就用着很顺手，不过是个注解 + 配置的事。但是对于不熟悉前端的我而言，这个就跟看天书一样，很是无力，我想，自定义有点远去了。</p>\n<p>我现在要干的事，是将这个获取静态资源的方式，直接以 api 的方式来调取后端接口，这个基于 vue 写 axios 我倒是没问题，后端 springboot 我也没问题，就是不知道如何分离这段前端的代码。按理说，这个前端的代码里面，肯定有获取 source 文件里面资源，然后调用 markdown 解析器，结合主题，将文档转化为 html 的一个过程。找到这个，将这个资源的获取，直接替换成 api，说起来很简单，但是我还没看代码，还不确定是不是这么简单。</p>\n<p>目前还不知道这个站内搜索的功能是不是直接 nodejs 做的，如果我不前后端分离的话，那就很简单，配置一下，也就是需要去找找文档，配置一下这块的东西，但我如果要分离的话…，同上</p>\n<p>最大的叹息就是他娘的，这个自定义主题的事了，我看到了我很喜欢的主题，但是人不开源，我也想自力更生一波，但是以前写前端都是小孩子过家家，搁大人面前玩泥巴，幼稚的很呐。那界面也是离谱的狠，哪有专门搞前端的厉害。</p>\n<p>吐槽归吐槽，还是该做啥做啥，目前就配置着用呗。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/",
            "url": "http://example.com/2023/07/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/",
            "title": "我的第一篇blog",
            "date_published": "2023-07-13T06:14:28.000Z",
            "content_html": "<blockquote><p>优雅的人，都要搞自己的博客。</p>\n<footer><strong>——鲁迅</strong></footer></blockquote>\n<p>当我接触到代码的小世界的时候，我就立志要写出优雅的代码。正当我为了这个宏伟的目标而努力的时候，偶然间我看见了鲁大师的名言，所以我来了！</p>\n<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>不知道大家是怎么想的，我打算搞个自己的博客的第一出发点就是，能够有个完全由自己 DIY 的小世界。<br>\n这个小世界，就好比小时候的秘密基地，只有你有这个地方的钥匙，可以天马行空，可以记录任何自己想记录的东西，是不是很激动，反正我内心激动无比。<br>\n这个小世界，就好比一扇单向可见的玻璃，当你建立域名，将这个小世界挂出去的时候，就感觉所有人都看到了，但是你的网址并没有被搜索引擎收录，当然可以配置，但是这种感觉就是相当的奇妙。<br>\n这个小世界，此处并没有排比，哈哈！<br>\nPS：我是真的想写好第一篇 blog 的前言，但是我一码字，就跟个手残党一样，脑子里骚操作一堆，实操只会平 A，skr…，麻了欸。</p>\n<h3 id=\"我是谁\"><a class=\"markdownIt-Anchor\" href=\"#我是谁\">#</a> 我是谁</h3>\n<p>哈哈哈，没错，我是这里的站长！！！<br>\n我命由我不由…，咳咳，</p>\n<h3 id=\"它是谁\"><a class=\"markdownIt-Anchor\" href=\"#它是谁\">#</a> 它是谁</h3>\n<p>这个有说法的，这个地方我想让它继承我毕生所学，将来世袭给…。总而言之，我想叫它多面体，为什么不叫冰柠檬…</p>\n<h3 id=\"我想干什么\"><a class=\"markdownIt-Anchor\" href=\"#我想干什么\">#</a> 我想干什么</h3>\n<p>这个也有说法的，直接整的专业点的好了。<br>\n作为一个站长，我有建设，维护和使用它的权力和义务。<br>\n所以<br>\n 1、我会在这里发文章，可以是技术文，口水文。目前来讲我是有很多想法的，我想写一些技术博客，却不放在 CSDN，知乎、掘金这些平台上面；我想发一些日常，但是却不发在朋友圈、空间、微博这些社交平台上面；我想记录一些金句，包括抽象的、富含文艺气息的以及其他；我想罗列一些自己的计划，可以是长期的 flag，也可以是短期的待办；我想…<br>\n2、我会改造多面体，真的，当你搞个自己的博客，你就感觉这就像你的孩子，你喜欢的人一样，想起它你就会情不自禁的嘴角上扬。目前这个博客只是静态的 page，用 Hexo 搭建的，使用的是 shokaX 主题，搞了个阿里的域名，静态资源挂在了 github 上面。我目前有很多很多的想法，但是鉴于个人能力，想法只能是想法，但是我已经迈出了最为艰难的一步，后面会写一篇关于我的建设的文章。<br>\n3、我会维护多面体，这也有很多的方面吧，运营方面的话，就是这个域名啊，后面我加的东西多了，我可能就得办个服务器，不能再用 github 来托管了；对于站点本身，也就是架构，如果时间够久，肯定会面临着技术架构翻新的时候，所以我也会尽量保证紧跟时代的潮流。我当然想自己搞个主题，100% 量身打造，可是现实很骨感，我就尽量挑选比较贴合自己阶段审美的主题，添加一些自己需要的功能、专栏；对于整个开发的流程，目前比较简陋，开发部署，搞个文章都很轻松，但是后面加入后台的前后端，并且数据量，整个平台的复杂度上来的话，我感觉需要使用 CI/CD 工具，并且加入数据分析等等东西，<br>\n总之，感觉目前就是处于头脑风暴阶段，什么都想干，什么都干不了，所以经验告诉我，我需要细化，我需要一步步慢慢来，我目前想到的最好的办法就是：<br>\n我面临的敌人前所未有的强大，我想建设好多面体，我就需要让我自己保持新鲜的活力，让自己承受刚刚好的压力，并且一直能够进步，我相信，这样的话我应该能走的远一些。<br>\n譬如，我另一个想法，我不打算搞这个博客站点的数据，打算随便搞点 md 进来，丰富一下数据，然后直接搞后端，搞一些数据分析，清洗数据，没准结合一下大语言模型等等，但是想着想着就不想搞了。<br>\n思来想去，我总觉得，要想长久经营下去，得要建立数据感情，也就是，这个站点的数据都是自己的，也就是这些文章都是我想发的，想写的，这样我才会想着更好的去建设多面体。<br>\n所以，我目前就打算多写一些文章，罗列一些技术栈，画一些设计文档等等</p>\n",
            "tags": [
                "hello blog"
            ]
        }
    ]
}