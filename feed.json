{
    "version": "https://jsonfeed.org/version/1",
    "title": "该死的秋招",
    "description": "孵化中···",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/09/14/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/",
            "url": "http://example.com/2023/09/14/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/",
            "title": "常见排序总结（为了手撕）",
            "date_published": "2023-09-14T12:58:06.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>总结一下常见的排序，主要以记录为主。排版就直接上代码 + 个人理解的思路。并且是本人习惯的编码风格。主要是为了防止手撕遇到，不然真不想总结这玩意…</p>\n<h3 id=\"冒泡\"><a class=\"markdownIt-Anchor\" href=\"#冒泡\">#</a> 冒泡</h3>\n<p>冒泡不打算上代码，直接讲个思路。<br>\n两层 for，以升序为例，每轮选最小的放前面，或者最大的放后面。<br>\n两两相邻比较，大的往后移即可。</p>\n<h3 id=\"选择\"><a class=\"markdownIt-Anchor\" href=\"#选择\">#</a> 选择</h3>\n<p>选择也一样不上代码，跟冒泡类似，只不过冒泡是每次都 swap，而选择是以 temp 记录每一轮的最大数，然后最后进行 swap 即可</p>\n<h3 id=\"快排\"><a class=\"markdownIt-Anchor\" href=\"#快排\">#</a> 快排</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">quicksort</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left &gt;= right) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        swap(nums, random.nextInt(right-left+<span class=\"number\">1</span>)+left, left);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sentinel</span> <span class=\"operator\">=</span> partition(nums,left, right);</span><br><span class=\"line\">        quicksort(nums,left, sentinel -<span class=\"number\">1</span>);</span><br><span class=\"line\">        quicksort(nums, sentinel +<span class=\"number\">1</span>, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">partition</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> left;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= nums[temp]) right--;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= nums[temp]) left++;</span><br><span class=\"line\">            swap(nums,left, right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(nums, temp, right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> nums[left];</span><br><span class=\"line\">        nums[left] = nums[right];</span><br><span class=\"line\">        nums[right] = temp;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码是加入了 random 的写法，目的是防止了一些极端的情况。说一下思路</p>\n<p>选择一个基准的 num，然后对左右两边再进行快排，明显是个分治（递归）。</p>\n<p>那么就是这个基准如何去找，单独拉出一个 partition 函数，以最左边的 num 为基准，左右两个指针 left 和 right 同时找小于等于和大于等于他的。注意，这里的等于要带上，不然会死循环，也就是 left 和 right 会不往中间走。需要注意的点就是 right 在前，不然会出现最终的位置错误。</p>\n<p>最后替换的那个 num 就是后续的切分点。</p>\n<h3 id=\"插入排序\"><a class=\"markdownIt-Anchor\" href=\"#插入排序\">#</a> 插入排序</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">InsertSort</span><span class=\"params\">(<span class=\"type\">int</span> arr[])</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; len; i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> arr[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> j;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = i-<span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j] &gt; tmp)&#123;</span><br><span class=\"line\">               arr[j+<span class=\"number\">1</span>] = arr[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[j+<span class=\"number\">1</span>] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>网上找的代码，具体没写过，直接说一下思路。</p>\n<p>插入的思想就是跟打牌抓牌，然后整理牌一样。</p>\n<p>两层 for，第一层相当于抽牌。第二层相当于找插入点。具体的思路就是将当前的牌的位置空出来，用 temp 接一下，升序的话就是大于当前牌的 num 往后移，否则退出循环，将 temp 插入到退出的那个点即可。</p>\n<p>优化：也就是利用的插入的特点吧，手里的牌必然是有序的，所以查找插入点可以用二分，所以会进一步降低复杂度。</p>\n<h3 id=\"希尔排序\"><a class=\"markdownIt-Anchor\" href=\"#希尔排序\">#</a> 希尔排序</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">shellSort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr == <span class=\"literal\">null</span> || arr.length &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">gap</span> <span class=\"operator\">=</span> arr.length / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (gap != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> arr[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i - gap;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; value; j -= gap) &#123;</span><br><span class=\"line\">                arr[j + gap] = arr[j]; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr[j + gap] = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        gap /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>网上考的代码，具体我也没写过。说一下具体的思路。</p>\n<p>大体的思路就是，分组进行插入排序，通过不断的缩小这个分组的长度来达到整体的排序效果。</p>\n<p>编码的思路和实际的讲解思路稍微有点不一样。讲解思路是对每一组进行插入排序，但是编码的思路是每次仅完成每一组的一个元素的位置寻找。说的形象一点就是，当前如果是第一组的第二个元素插入，那么 i 的下一轮就是第二组的第二个元素的插入，所以稍微有点不一样，看代码就知道了 i++，插入的话，j 是 j-gap 跳着找。没有图还是比较抽象，，，</p>\n<h3 id=\"堆排\"><a class=\"markdownIt-Anchor\" href=\"#堆排\">#</a> 堆排</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">heapsort</span><span class=\"params\">(<span class=\"type\">int</span> n[])</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> n.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">        buildHeap(n, i);</span><br><span class=\"line\">        swap(n, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buildHeap</span><span class=\"params\">(<span class=\"type\">int</span> n[], <span class=\"type\">int</span> end)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> end + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> len / <span class=\"number\">2</span> - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> <span class=\"number\">2</span> * i + <span class=\"number\">1</span>, r = l + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> l;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r &lt;= len - <span class=\"number\">1</span> &amp;&amp; n[l] &lt; n[r]) &#123;</span><br><span class=\"line\">            p = r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n[i] &lt; n[p]) &#123;</span><br><span class=\"line\">            swap(n, i, p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接贴的网上的代码，应该是教科书代码。具体的思路如下：</p>\n<p>堆排的最直观的思路是，加入是大顶堆，每次能取到最大的元素，将这个最大的元素摆放在最后的位置即可，重点在于怎么写这个大顶堆，这边看的时候也是刷新了一下思维。</p>\n<p>一直以为像堆这种的树结构，都是 treenode 节点，通过指针来跳的，但是那样的话就会很难写。以前一直不知道这个堆该怎么手撕，现在看上面的代码。</p>\n<p>heapsort 是整体的结构，每次取 i-n 的元素进行重新的堆排，而排好的，也就是堆顶，放到末尾。</p>\n<p>buildheap 就是如何调整这个堆的，很神奇。这边有一些我认为的先验知识，首先堆的起始点是 n/2，因为是完全二叉树，所以有子节点的最后一个节点必然是 n/2 的位置。其次如果当前节点为 i ，那么其子节点就是 2i 和 2i+1，所以将 i 和 2i 与 2i+1 比较，找出最大的然后 swap 即可（注意：上面的代码是从 0 下标开始的，也就是没有做处理，我看有的讲解是将第一个位置空出来，然后下标就可以和我上面的对上；但是上面的代码更实际，也就是统一 -1）</p>\n<p>​\t上面这个 buildheap 代码思路，就是判断是否有右子树，有的话，标出大的那个，如果根节点小于大的那个，那么就换上去，依次类推，十分简单，堆就构造完了。</p>\n<h3 id=\"归并排序\"><a class=\"markdownIt-Anchor\" href=\"#归并排序\">#</a> 归并排序</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span>[] sortArray(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(left == right) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;nums[left]&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> merge(sortArray(nums,left,mid),sortArray(nums,mid+<span class=\"number\">1</span>,right));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span>[] merge(<span class=\"type\">int</span>[] leftArr, <span class=\"type\">int</span>[] rightArr)&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[leftArr.length + rightArr.length];</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, right = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; res.length; i ++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left &gt;= leftArr.length) res[i] = rightArr[right++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(right &gt;= rightArr.length) res[i] = leftArr[left++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(leftArr[left] &lt; rightArr[right]) res[i] = leftArr[left++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> res[i] = rightArr[right++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分治思想，有点和快排类似，但是归并比快排更稳定，也就是当纯倒序，快排会退化成 O (n^2)。</p>\n<p>这是之前写的代码，也就是一贯的风格，用 int [] 来接，并且用 split 和 merge 两个组成归并排序。</p>\n<p>大体的思路就是不停的切，每次找 num 的 mid，切开；left 到 mid，mid+1 到 right；也很简单，split 不用说了，就是找 mid，切开；merge 的话就是合并两个有序的数组，很简单。</p>\n<h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>以上就是我接触的常见的排序了，感觉也是了结了一个心事。其中常写的就是快排和归并，总结一下就是很简单，也就这两个我贴的我自己的代码风格。</p>\n<p>欧凯，结束，排序了结，希望手撕到这种题目的时候我可以秒斯，yes</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/09/14/%E8%AE%A9%E8%87%AA%E5%B7%B1%E6%85%A2%E4%B8%8B%E6%9D%A5/",
            "url": "http://example.com/2023/09/14/%E8%AE%A9%E8%87%AA%E5%B7%B1%E6%85%A2%E4%B8%8B%E6%9D%A5/",
            "title": "让自己慢下来",
            "date_published": "2023-09-14T11:10:06.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>工作难找，* 难吃，欸</p>\n<h3 id=\"新阶段\"><a class=\"markdownIt-Anchor\" href=\"#新阶段\">#</a> 新阶段</h3>\n<p>所谓厚积薄发，书到用时方恨少。所以，在大火都着急 offer 的时候，我打算稳住自己的节奏，缓步推进学习计划。<br>\n俗话说的好，最大的敌人就是你自己。不能自乱阵脚，只要我在进步，那么总有接近目标的一天，yes</p>\n<h3 id=\"计划\"><a class=\"markdownIt-Anchor\" href=\"#计划\">#</a> 计划</h3>\n<p>频繁且少量的更新自己的知识点，虽然网上都有，但这也就是类似于默写吧，加深记忆。<br>\n自己的理解，所以可能有错误。<br>\npeace &amp; love</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/18/%E5%AE%9E%E4%B9%A0%E6%B1%87%E6%80%BB/",
            "url": "http://example.com/2023/07/18/%E5%AE%9E%E4%B9%A0%E6%B1%87%E6%80%BB/",
            "title": "实习汇总",
            "date_published": "2023-07-18T11:10:06.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>本篇是技术文。<br>\n实习以来，接触了很多的东西，下面从几个方面简单罗列一下：</p>\n<ul>\n<li>语言：Java、Python</li>\n<li>框架：SpringBoot、Hibernate、Mybatis、Django</li>\n<li>数据：MySQL、Milvus、ElasticSearch、Ceph<br>\nPS：Ceph 分布式存储，我不知道应不应该这么分类，在公司的具体的用法就是通过 Swift/S3，与分布式存储系统进行交互，具体的业务就接触过上传附件。还有很多其他的东西，我不知道该怎么分类，我想把他们分为工具的，但是总感觉不合适，可能是因为没弄懂，确实是没弄懂，后面单独讲。</li>\n</ul>\n<h3 id=\"粗略的过一下\"><a class=\"markdownIt-Anchor\" href=\"#粗略的过一下\">#</a> 粗略的过一下</h3>\n<p>这篇我没有详细的框架，但是有个很明确的想法（串一下目前接触到的技术），所以肯定全部是略讲。<br>\n串的话，我主要打算按照时间线来，回顾一下两个月接触到的各种工具、技术…</p>\n<h4 id=\"单元测试\"><a class=\"markdownIt-Anchor\" href=\"#单元测试\">#</a> 单元测试</h4>\n<p>刚开始来的时候，我主要是写 Junit 来熟悉组内接手的业务，这边先是写的 Java 项目的单元测试，后面又写了 Python 的单元测试。<br>\n对于 Java 而言，组内使用的框架是 Junit+PowerMockito。这边讲一下单元测试主要的思想：检验代码逻辑，按照软件工程的概念，就是对于业务代码的测试，也属于最底层的测试了，所以一般是由程序员编写测试用例。组内使用的框架是 Junit+PowerMockito，感觉主要的还是 mock，也就是所谓的打桩（模拟）。通过模拟当前程序之外的对象 / 函数，来检验逻辑的正确性。Java 主要就是通过 PowerMockito 来模拟对象，以及对象的行为。其中印象比较深刻的点在于可变参数方法的 mock、多线程 mock 以及有无返回值方法的 mock，其他的感觉都是一些正常的 mock。<br>\n对于 Python 而言，和 Java 对应的话，就是 TestCase+mock。接触的 Junit 是基于 Django 写的后端的前台管理，使用的是 Django 内部的 TestCase+Python 的 Patch+MagicMock。测试类继承 TestCase，使用 @patch 来模拟方法以及 MagicMock 来模拟对象。@patch 相当于注入，MagicMock 相当于 new，可以简单的这么理解。其中印象深刻的点在于，@patch 注入和方法中的参数是相反的（这边描述的很抽象，我也没截图，大概只有我自己能看懂）、需要额外定义 side_effect 函数，并且传给 mock 对象的 side_effect 属性，来模拟对象的行为、Python 中比较抽象的在于它 @patch 传入方法不是对象，这个 Java 相比还是很大区别的，当时也被坑了好久，其他的感觉也就正常吧，主要是和 Java 有很多不一样的点。<br>\nPS：其中对于测试用例的书写，大致是通过数据库表结构或者代码中用到的属性来 mock；正规是要最后使用 assert 来断言，但是我目前还没体会到这个 assert 的作用，总感觉不好用；不太科学的衡量标准，检测当前 UT 的标准是覆盖率。</p>\n<h4 id=\"项目开发\"><a class=\"markdownIt-Anchor\" href=\"#项目开发\">#</a> 项目开发</h4>\n<p>其一，完整的项目开发就是公司提供的 MIT，针对校招生的开发实践，目的主要是为了熟悉公司的工具和框架吧。<br>\n这个项目非常的完整，从 0 开始，需要申请 App ID，走公司的流水线平台。这个 App ID 就是公司识别项目的唯一标志。流水线的话，可以理解为一条龙吧，主要是 CI/CD（持续集成）。这边有很多的概念，我主要讲一下这流水线中涉及到的东西吧。将 Git 与 CI/CD 工具关联（公司平台做了），当 push 的时候，自动生成对应的镜像，平台可以配置集群（针对项目，也就是项目可以部署在多个服务器上，可以做一些访问限制以及负载均衡），很多功能，更多的是作为一个工具，这个平台也就是将项目开发部署和维护都交给程序员了，这也是 CI/CD 的核心理念吧。申请 App ID 之后，就相当于有了一个通行证吧，然后通过公司的脚手架创建 SpringBoot Web 项目。通过脚手架创建的好处，就是公司内部的一些默认配置会给你设定好。这边就涉及到公司使用的 BOM（写在 POM 中，公司内部的 Jar 包版本管理，原理没有了解过），其作用相当于<dependencyManagement>，后续使用公司内部的 Jar 包就不需要指定版本了，也避免了一些版本冲突。从数据说起的话，就是题目提供的 mysql 和 Redis，两个都是公司建好的集群（公司内部一般数据都是统一化管理，并且封装一层访问方式，为了避免密码的配置）。公司通过 DAL（应该是公司内部封装的 mysql 的连接方式）建立与 mysql 的数据连接，Redis 的话是直接调的公司的 Jar 包。当然要配置 SqlSession，也就是这边深刻理解了 bean 的注入，对于以上两者都需要进行 config 的注入，将数据连接交给 spring 管理。Redis 比较简单的使用，mysql 的话，还需要使用 JPA 规范，这里使用的是 Mybatis Plus，这边深刻理解了 Mybatis Plus 对于 SqlSession 的封装注入，与 Mybatis 还是不一样的。然后就是做一些基础的 CRUD 了。<br>\n除了基本的业务之外，这里面增加了很多其他的东西：QMQ 消息的收发（公司内部也封装了消息中间件，个人感觉就是集群化了）。通过 Baiji 规范写 SOA 服务，并且发到公司内部的 SOA 平台上，通过 Client 实现并调用（跟 Jar 包一样）。VI 点火，也就是项目启动的时候，需要验证是否满足项目启动的标准，当然可以在项目启动之前做一些操作，比如资源的加载什么的。重量级的就是 log 埋点了，出 bug 才知道日志的重要性。所以公司有很多关于日志的平台 CLog、Cat、Dashboard…，公司内部封装很多工具，将 @slf4j 生成的 log 直接上传到 log 管理平台，提供日志分析等等。深刻体会日志埋点的重要性。<br>\nPS：这个学到了很多的东西，除去熟悉了公司的工具和技术架构之外，从头到尾捋顺了项目的开发。建立了一个比较规范的包结构。深入理解了对象注入。</p>\n<p>其二，非完整项目开发，也就是对已有项目修改，或者开发一些新的接口。<br>\n第一个场景是合并带有时间戳的数据库记录，类似于交并集的算法题。说的专业点的话，就是先 sort，使用贪心进行记录的合并。基本和算法题一模一样，只是涉及了一点业务背景，其中涉及到对象解包，也就是将内部封装好的 DTO 对象，通过 BeanUtil 拆解为 map 集合，然后再添加一些新的键值对，返回给前端。上次用的 apache 的 BeanUtil，但是建议貌似使用 mapstruct 比较好一点。第二个场景与 ElasticSearch 相关，其实需求很简单，就是根据用户当前的状态信息，筛选 es 上的数据。了解了 es 的数据结构，一如既往，对于数据库而言，肯定有配套的语句，而最难的肯定是 select。对于 es 也一样，我大部分经历也是在学习它的语法，后面会有专门的文章来分享一下 es，从搭建到检索。这个项目并没有使用目前现有的工具，历史原因吧可能，直接使用的 template 模板文件来生成语句（这边提一嘴，这也就是底层吧，比如使用其他的工具的时候，就是对于这个模板语句的生成做了封装），这边学到的点就是对于 freemarker 这类的模板工具有了深刻的理解，后面也打算深入学习一下，然后搞一篇。第三个场景是附件上传，这边接触到了 Ceph，两类访问方式吧（Swift 和 S3），目前只知道这是个分布式的存储系统，实现的话也是通过 Swift/S3 连接服务器，然后上传的话，直接返回一个 URL，可以直接以 get 方式下载资源。实现也很简单吧，但是里面的东西还是很多的。一个是了解了 Session 和 Cookie，因为 Session 是服务端加工的，一般要 setAttribute，所以对于 controller 拿数据的时候，@requstParam 和 @requestAttribute 还是不一样的，细品，反正我经过这个接口直接深入体会。还有的话就是这里的一个工程性的点，一般对于这个需求的话，我直接上传返回 URL 直接就结束了，但是我从佳文那里学到的点就是，本地需要建立一张附件信息表，记录上传的附件信息，是不是很有必要！</p>\n<h4 id=\"结尾\"><a class=\"markdownIt-Anchor\" href=\"#结尾\">#</a> 结尾</h4>\n<p>说实话，真的很难写。<br>\n一个是我的语言表达一向有很大的问题，二者确实脑子现在很混乱，有很多就没有理清楚…<br>\n 所以我也就抱着记录一下的心态来写，主要是记录一下涉及到的知识点吧，后面理清楚一点再重新写这篇，并且其中也埋下了很多技术坑，不知道有生之年能不能填上。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/15/%E6%90%AD%E5%BB%BA%E5%A4%9A%E9%9D%A2%E4%BD%93%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8A%E6%8B%A6%E8%B7%AF%E8%99%8E/",
            "url": "http://example.com/2023/07/15/%E6%90%AD%E5%BB%BA%E5%A4%9A%E9%9D%A2%E4%BD%93%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8A%E6%8B%A6%E8%B7%AF%E8%99%8E/",
            "title": "搭建”多面体“的架构以及拦路虎",
            "date_published": "2023-07-15T08:38:28.000Z",
            "content_html": "<p><img data-src=\"https://i.imgtg.com/2023/07/15/OzdvOt.png\" alt=\"Alt Text\"></p>\n<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<blockquote><p>天不生我大白鹅，画界万股如长夜！</p>\n<footer><strong>——毕加索</strong></footer></blockquote>\n<p>咳咳，如大家所见，鄙人走的抽象派…<br>\n 今天我们就来纸上谈兵一手，分析一下，如何靠的一张嘴，搭建一个前后端系统。</p>\n<h3 id=\"多面体的架构\"><a class=\"markdownIt-Anchor\" href=\"#多面体的架构\">#</a> “多面体” 的架构</h3>\n<p>先是自身的想法，我想将这个静态的博客，搭建成一个前后端分离的博客系统。为什么这么想呢，主要有几个原因：<br>\n其一，实习学到的一点技能，想找个地方挥霍一把。<br>\n其二，就想拆一下这个 hexo 搭建的静态 page<br>\n 其三，很主要的原因，主要是不想写论文，找点喜欢的事做做…</p>\n<p>可以从图上得知，本人的画技如此的滑稽…，<br>\n可以从上图得知，我想将 Hexo 作为一个只生成博客的空壳，将数据从里面分离出来，持久化到 mysql，然后通过后端的 API，将数据返回给前端，这样就前后端分离了。那么能不能有个发布博客的后台呢，以及统计一些数据、展示图表的后台呢，我觉得可以有，这样直接就可以线上，可以线下了，岂不美滋滋。</p>\n<p>大体而言，外面能看到的，也就是域名能够访问到的，当然还是和之前一样，只有博客。我目前还没有完全想好这个博客是不是要动态资源，还是直接用前端的技术来做检索，并且还将资源直接以静态的方式存储在服务器上。然后备份一份（所谓的持久化到 mysql），给后端做处理，在后台管理页面也能展示不一样的东西。因为如果这样做的话，有几个优势吧：<br>\n其一，消耗的资源小，并且静态的博客也可以完全用之前的一套，少消耗点精力，再者我不用另外租服务器了<br>\n其二，这本来就没打算给外界访问，所以后台做线下处理很符合我的需求，但是就是需要手动同步数据，就很无语，不知道有什么什么其他的好方法。</p>\n<p>但是思来想去，还是觉得前后端分离要高大上一点，也就是有违博客的初衷了。</p>\n<h3 id=\"拦路虎\"><a class=\"markdownIt-Anchor\" href=\"#拦路虎\">#</a> 拦路虎</h3>\n<p>唉，直接叹气，md<br>\n 简直对前端一窍不通，主要是感觉之前学的 vue，以及一些基础的 html，css，js。到如今这个封装的不像样的年代，总感觉中间搁着好多层，就好比后端，springboot 和原生的 java 也搁着好多层，但是熟悉的就用着很顺手，不过是个注解 + 配置的事。但是对于不熟悉前端的我而言，这个就跟看天书一样，很是无力，我想，自定义有点远去了。</p>\n<p>我现在要干的事，是将这个获取静态资源的方式，直接以 api 的方式来调取后端接口，这个基于 vue 写 axios 我倒是没问题，后端 springboot 我也没问题，就是不知道如何分离这段前端的代码。按理说，这个前端的代码里面，肯定有获取 source 文件里面资源，然后调用 markdown 解析器，结合主题，将文档转化为 html 的一个过程。找到这个，将这个资源的获取，直接替换成 api，说起来很简单，但是我还没看代码，还不确定是不是这么简单。</p>\n<p>目前还不知道这个站内搜索的功能是不是直接 nodejs 做的，如果我不前后端分离的话，那就很简单，配置一下，也就是需要去找找文档，配置一下这块的东西，但我如果要分离的话…，同上</p>\n<p>最大的叹息就是他娘的，这个自定义主题的事了，我看到了我很喜欢的主题，但是人不开源，我也想自力更生一波，但是以前写前端都是小孩子过家家，搁大人面前玩泥巴，幼稚的很呐。那界面也是离谱的狠，哪有专门搞前端的厉害。</p>\n<p>吐槽归吐槽，还是该做啥做啥，目前就配置着用呗。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/",
            "url": "http://example.com/2023/07/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/",
            "title": "我的第一篇blog",
            "date_published": "2023-07-13T06:14:28.000Z",
            "content_html": "<blockquote><p>优雅的人，都要搞自己的博客。</p>\n<footer><strong>——鲁迅</strong></footer></blockquote>\n<p>当我接触到代码的小世界的时候，我就立志要写出优雅的代码。正当我为了这个宏伟的目标而努力的时候，偶然间我看见了鲁大师的名言，所以我来了！</p>\n<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>不知道大家是怎么想的，我打算搞个自己的博客的第一出发点就是，能够有个完全由自己 DIY 的小世界。<br>\n这个小世界，就好比小时候的秘密基地，只有你有这个地方的钥匙，可以天马行空，可以记录任何自己想记录的东西，是不是很激动，反正我内心激动无比。<br>\n这个小世界，就好比一扇单向可见的玻璃，当你建立域名，将这个小世界挂出去的时候，就感觉所有人都看到了，但是你的网址并没有被搜索引擎收录，当然可以配置，但是这种感觉就是相当的奇妙。<br>\n这个小世界，此处并没有排比，哈哈！<br>\nPS：我是真的想写好第一篇 blog 的前言，但是我一码字，就跟个手残党一样，脑子里骚操作一堆，实操只会平 A，skr…，麻了欸。</p>\n<h3 id=\"我是谁\"><a class=\"markdownIt-Anchor\" href=\"#我是谁\">#</a> 我是谁</h3>\n<p>哈哈哈，没错，我是这里的站长！！！<br>\n我命由我不由…，咳咳，</p>\n<h3 id=\"它是谁\"><a class=\"markdownIt-Anchor\" href=\"#它是谁\">#</a> 它是谁</h3>\n<p>这个有说法的，这个地方我想让它继承我毕生所学，将来世袭给…。总而言之，我想叫它多面体，为什么不叫冰柠檬…</p>\n<h3 id=\"我想干什么\"><a class=\"markdownIt-Anchor\" href=\"#我想干什么\">#</a> 我想干什么</h3>\n<p>这个也有说法的，直接整的专业点的好了。<br>\n作为一个站长，我有建设，维护和使用它的权力和义务。<br>\n所以<br>\n 1、我会在这里发文章，可以是技术文，口水文。目前来讲我是有很多想法的，我想写一些技术博客，却不放在 CSDN，知乎、掘金这些平台上面；我想发一些日常，但是却不发在朋友圈、空间、微博这些社交平台上面；我想记录一些金句，包括抽象的、富含文艺气息的以及其他；我想罗列一些自己的计划，可以是长期的 flag，也可以是短期的待办；我想…<br>\n2、我会改造多面体，真的，当你搞个自己的博客，你就感觉这就像你的孩子，你喜欢的人一样，想起它你就会情不自禁的嘴角上扬。目前这个博客只是静态的 page，用 Hexo 搭建的，使用的是 shokaX 主题，搞了个阿里的域名，静态资源挂在了 github 上面。我目前有很多很多的想法，但是鉴于个人能力，想法只能是想法，但是我已经迈出了最为艰难的一步，后面会写一篇关于我的建设的文章。<br>\n3、我会维护多面体，这也有很多的方面吧，运营方面的话，就是这个域名啊，后面我加的东西多了，我可能就得办个服务器，不能再用 github 来托管了；对于站点本身，也就是架构，如果时间够久，肯定会面临着技术架构翻新的时候，所以我也会尽量保证紧跟时代的潮流。我当然想自己搞个主题，100% 量身打造，可是现实很骨感，我就尽量挑选比较贴合自己阶段审美的主题，添加一些自己需要的功能、专栏；对于整个开发的流程，目前比较简陋，开发部署，搞个文章都很轻松，但是后面加入后台的前后端，并且数据量，整个平台的复杂度上来的话，我感觉需要使用 CI/CD 工具，并且加入数据分析等等东西，<br>\n总之，感觉目前就是处于头脑风暴阶段，什么都想干，什么都干不了，所以经验告诉我，我需要细化，我需要一步步慢慢来，我目前想到的最好的办法就是：<br>\n我面临的敌人前所未有的强大，我想建设好多面体，我就需要让我自己保持新鲜的活力，让自己承受刚刚好的压力，并且一直能够进步，我相信，这样的话我应该能走的远一些。<br>\n譬如，我另一个想法，我不打算搞这个博客站点的数据，打算随便搞点 md 进来，丰富一下数据，然后直接搞后端，搞一些数据分析，清洗数据，没准结合一下大语言模型等等，但是想着想着就不想搞了。<br>\n思来想去，我总觉得，要想长久经营下去，得要建立数据感情，也就是，这个站点的数据都是自己的，也就是这些文章都是我想发的，想写的，这样我才会想着更好的去建设多面体。<br>\n所以，我目前就打算多写一些文章，罗列一些技术栈，画一些设计文档等等</p>\n",
            "tags": [
                "hello blog"
            ]
        }
    ]
}