{
    "version": "https://jsonfeed.org/version/1",
    "title": "该死的秋招",
    "description": "孵化中···",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/09/28/%E5%B9%82%E7%AD%89%E5%AE%9E%E7%8E%B0/",
            "url": "http://example.com/2023/09/28/%E5%B9%82%E7%AD%89%E5%AE%9E%E7%8E%B0/",
            "title": "幂等实现",
            "date_published": "2023-09-28T07:06:03.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>关于幂等的实现，属于是一个高频的面试题吧，所以直接做一个记录，其实这是很大的一块</p>\n<h3 id=\"定义\"><a class=\"markdownIt-Anchor\" href=\"#定义\">#</a> 定义</h3>\n<p>幂等原先用于数学领域，转到计算机就是接口幂等，那么也就是多次请求效果和一次一样。</p>\n<h3 id=\"产生的背景\"><a class=\"markdownIt-Anchor\" href=\"#产生的背景\">#</a> 产生的背景</h3>\n<ul>\n<li>恶意</li>\n<li>客户端重复提交，也就是 button 的问题，表单重复提交</li>\n<li>超时重试，这个背景包括前后端连接超时，前端等待后端结果超时，主要是后者</li>\n<li>重复消费，感觉有点勉强（可说可不说吧，主要是没有用到 mq）</li>\n</ul>\n<h3 id=\"引入幂等的后果\"><a class=\"markdownIt-Anchor\" href=\"#引入幂等的后果\">#</a> 引入幂等的后果</h3>\n<ul>\n<li>增加后端处理逻辑，因为要判重等</li>\n<li>将并行改为串行，简单点说就是直接通过单通道限制资源<br>\n所以就是说建议非必要不幂等，感觉也就是一些支付啊什么的需要幂等，要么就直接限制前端就行了。</li>\n</ul>\n<h3 id=\"幂等的实现方案\"><a class=\"markdownIt-Anchor\" href=\"#幂等的实现方案\">#</a> 幂等的实现方案</h3>\n<p>感觉总的可以分为这样几大类：</p>\n<ul>\n<li>insert，也就是有唯一主键来做约束，交给数据库，落库就主键冲突</li>\n<li>update，这个时候就涉及到锁了，乐观，悲观以及分布式锁</li>\n</ul>\n<h4 id=\"insert操作\"><a class=\"markdownIt-Anchor\" href=\"#insert操作\">#</a> insert 操作</h4>\n<p>通过主键给个防重表，如果重复了，那么返回成功，否则就执行。<br>\n网上有个说法：对于并发大的使用 select 再 insert（这边就要加锁了，因为是两个步骤），对于并发不大的直接使用 insert；个人觉得没什么道理，后面再看。</p>\n<p>使用防重表，主要是为了实现业务和判重分离，其实直接用业务表的主键也是可以的。</p>\n<h3 id=\"update\"><a class=\"markdownIt-Anchor\" href=\"#update\">#</a> update</h3>\n<h4 id=\"token\"><a class=\"markdownIt-Anchor\" href=\"#token\">#</a> token</h4>\n<p>token，借助 redis；客户端发送请求，服务端给出唯一 token，先落库 redis 还是先给客户端，感觉有说法；然后客户端携带着 token 来第二次请求，请求成功那么执行并删除 token；否则幂等，直接返回。</p>\n<p>token 建议用雪花算法，也就是时间戳 41 位 + 主机 + 随机</p>\n<h4 id=\"上锁\"><a class=\"markdownIt-Anchor\" href=\"#上锁\">#</a> 上锁</h4>\n<ul>\n<li>悲观锁，select for update</li>\n<li>乐观锁，加入自增版本号，用 cas 也就是携带着版本号进行 insert；也就是先 select 获取版本号，然后 insert</li>\n<li>分布式锁，可以使用 zookeeper 和 redis，具体的使用感觉有点儿麻烦，目前不是很会，大致的就是获取到分布式锁了就执行，否则直接返回。</li>\n</ul>\n",
            "tags": [
                "分布式"
            ]
        },
        {
            "id": "http://example.com/2023/09/26/%E8%B7%B3%E8%A1%A8%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91/",
            "url": "http://example.com/2023/09/26/%E8%B7%B3%E8%A1%A8%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91/",
            "title": "跳表和红黑树",
            "date_published": "2023-09-26T13:03:51.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>之前看 hashmap 的时候，研究过红黑树。前段时间同学面携程的时候，面试官给了跳表的八股文，我看到也懵了。翻阅相关资料才知道跳表和红黑树之前还有一定的联系，下面我们来看看。</p>\n<h3 id=\"跳表\"><a class=\"markdownIt-Anchor\" href=\"#跳表\">#</a> 跳表</h3>\n<p><a href=\"https://pic.imgdb.cn/item/6512d769c458853aeff45850.jpg\"><img data-src=\"https://pic.imgdb.cn/item/6512d769c458853aeff45850.jpg\" alt=\"\"></a><br>\n如上图所示，这个就是跳表。</p>\n<ul>\n<li>需要一个有序的链表</li>\n<li>在有序链表之上建立 n/2 个元素，称之为第一层索引，以此类推，最高层两个索引，由此可以推算出高度，从而时间复杂度为 logn</li>\n<li>每个元素都有两个属性，一个 val，一个指向下一个的指针，所以很适合做范围查找</li>\n<li>以空间换时间，这样的话，空间一大，那么代表就是复杂度就下来了，主打的就是一个奢侈。</li>\n</ul>\n<h3 id=\"红黑树\"><a class=\"markdownIt-Anchor\" href=\"#红黑树\">#</a> 红黑树</h3>\n<p><img data-src=\"https://pic.imgdb.cn/item/6512d93bc458853aeff55fdd.jpg\" alt=\"\"><br>\n先来讲一下红黑树的特征</p>\n<ul>\n<li>节点是红色或者黑色</li>\n<li>根节点黑色</li>\n<li>任意一条从根节点到叶子节点路径的黑色节点数量相同</li>\n<li>一条路径不能包含连续的两个红色节点 —》从而可以推出红色节点的父节点必然是黑色</li>\n<li>红黑树中的叶子节点有点不同，他的叶子节点都是 null</li>\n</ul>\n<h4 id=\"红黑树的发展史\"><a class=\"markdownIt-Anchor\" href=\"#红黑树的发展史\">#</a> 红黑树的发展史</h4>\n<p>这也是之前学习的时候了解了一点，这里就简单的总结一下，为什么会发展到红黑树，毕竟一个技术的诞生肯定是有历史的。<br>\n首先就是从数组和链表说起了，众所不周知，数组是查询 O1，链表是删除 O1（当然这里不是说的定位到再删除）。那么除了组合数据结构，就诞生了树结构。如果不限制树的高度，也就是平衡，那么树结构就会退化为链表，所以查询也会退化到 On。后面引入了 AVL，自平衡二叉树。也就是通过自旋的方式来调整树的高度。由于满足平衡二叉树的条件比较苛刻，导致插入数据后的自选频次很高，所以引入了红黑树。红黑树只需要满足一条路径上的黑色节点数相同就行了，所以如果一条全黑，一条间隔红黑，那么最长可以 n/2 不用调整。</p>\n<h4 id=\"红黑树变形\"><a class=\"markdownIt-Anchor\" href=\"#红黑树变形\">#</a> 红黑树变形</h4>\n<p>将红色节点上移到其父节点，那么就会形成 B 树一样的结构，四阶 B 树（节点元素最多为 3 个）</p>\n<h4 id=\"自旋\"><a class=\"markdownIt-Anchor\" href=\"#自旋\">#</a> 自旋</h4>\n<p>些许复杂，后面再搞</p>\n<h3 id=\"跳表和红黑树\"><a class=\"markdownIt-Anchor\" href=\"#跳表和红黑树\">#</a> 跳表和红黑树</h3>\n<p>hashmap 为什么不用跳表？<br>\n我看到一篇博客说的很有道理，就是 hashmap 存在 hash 冲突才用的红黑树存储相同 hash 散列后得元素，所以这个红黑树虽然是有序得，但是要明白一点，跳表得作用场景是范围查找，且需要空间换时间，但是这边散列后的元素其范围查找值我觉得有意义，但是并不完整，因为这里得范围只是冲突后的元素，那么没冲突得元素，但是在范围内得就无法被跳表涵盖进来。</p>\n<p>总的来说，就两点：</p>\n<ul>\n<li>红黑树不占用额外的空间</li>\n<li>hashmap 无序存储，没有范围查找的要求，所以用跳表的话，这个范围查找就没有任何的意义。准确点来说，hashmap 只需要精确查找，通过叶子节点来缩小范围，那么跳表是可以做范围检索的。</li>\n</ul>\n<p>但是总的感觉就是跳表和红黑树其实没差别，说用这个为什么不用那个，感觉有点牵强，你要说用，那么也不是不可以用。</p>\n<h3 id=\"跳表和b树\"><a class=\"markdownIt-Anchor\" href=\"#跳表和b树\">#</a> 跳表和 B + 树</h3>\n<p>也就是 redis 用了跳表，个人感觉，zset 他是要做范围查找的，那么就需要和 B + 树做个横向对比。<br>\nB + 树首先实现肯定较为复杂（当然网上也有说你用跳表，那么也要和随机平衡树的实现作比较，，麻），其次我觉得最主要的就是 B + 树和跳表都可以做范围查找，其次两者都是有索引节点，也就是上面的节点都是额外增加的，仅用来索引，所以跳表的可变的参数就有优势了，那么选定搁 n 个抽取，那么就可以适当减少空间的占用。</p>\n<h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>感觉没什么好说的，网上的说法也是没有一点说服力，我也没有去查阅官方的文档（一个没兴趣，二个估计看了也是云里雾里），so，问到就说点自己的想法，爱谁谁。</p>\n",
            "tags": [
                "数据结构"
            ]
        },
        {
            "id": "http://example.com/2023/09/25/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7/",
            "url": "http://example.com/2023/09/25/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7/",
            "title": "事务的隔离性",
            "date_published": "2023-09-25T09:44:47.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>一直有种面对隔离级别的恐惧，这次看懂了，稍做记录</p>\n<h3 id=\"基本概念\"><a class=\"markdownIt-Anchor\" href=\"#基本概念\">#</a> 基本概念</h3>\n<p>如果是单线程，那么完全不会出现什么问题。直到多线程的出现，就引发了一些列的问题：脏读，不可重复读，幻读。简单解释一下：</p>\n<ul>\n<li>脏读：一个事务读取到了另一个没有提交事务修改过的数据</li>\n<li>不可重复读：一个事务内，两次读取到的同一数据的内容不一样</li>\n<li>幻读：一个事务内，查询符合条件的记录数，两次读到的记录数不一样<br>\n以上的严重性，就是由上到下递减。</li>\n</ul>\n<p>与之对应的有几个隔离级别：</p>\n<ul>\n<li>读未提交</li>\n<li>读已提交</li>\n<li>可重复读</li>\n<li>串行<br>\n innodb 存储引擎，默认的隔离级别是可重复读。<br>\n简单点来说的话就是，读未提交就是读最新数据；读已提交就是可以读到其他事务提交的内容；可重复读就是可以重复读取相同的数据；串行，就是事务挨着事务，加锁了。</li>\n</ul>\n<h3 id=\"read-view和隐藏字段\"><a class=\"markdownIt-Anchor\" href=\"#read-view和隐藏字段\">#</a> Read view 和隐藏字段</h3>\n<p>一条记录有两个隐藏字段：trx_id 和 roll_pointer；分别表示最新修改的事务的 id 和指向 undo_log 中的日志指针。</p>\n<p>read view 说白了就是有关事务 id 的一种数据结构，这里面的主要结构就是四个字段：</p>\n<ul>\n<li>min_trx_id：当前存在的 id 最小的事务（注：事务的 id 是自增长的）</li>\n<li>max_trx_id：下一个事务 id</li>\n<li>m_ids：当前存在的事务 id 列表</li>\n<li>creator_trx_id：创建的事务 id</li>\n</ul>\n<h3 id=\"mvcc多版本并发控制实现\"><a class=\"markdownIt-Anchor\" href=\"#mvcc多版本并发控制实现\">#</a> mvcc（多版本并发控制）实现</h3>\n<p>感觉也没什么高深的，看了才知道就是利用上面的字段来完成的，也就是要明白一些规则。<br>\n注意：这边我刚明白的一点，read view 的创建和事务没有必然的关系，也就是 read view 可以是在事务中创建，也可以在一开始创建也就对应这两种隔离级别，所以 min，max，ids 这几个字段才有了不可替代性。</p>\n<ul>\n<li>对于不活跃的资源我可以改动，也就是小于 min 的。</li>\n<li>对于未创建的我不能改动，也就是大于等于 max 的</li>\n<li>对于之间的，也就要看在不在 ids 中了，也就是这个事务提交了没有。如果我创建 read view 的时候，他提交了，那么我就可以读了。</li>\n</ul>\n<p>看到了哪些可以读，那么就直接读，如果不可以读，就顺着 roll_pointer 链找下去，也就是找之前的记录，来完成当前的事务的隔离。</p>\n",
            "tags": [
                "MySQL"
            ]
        },
        {
            "id": "http://example.com/2023/09/22/%E7%AC%94%E8%AF%95%E9%80%89%E6%8B%A9%E9%A2%98%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/",
            "url": "http://example.com/2023/09/22/%E7%AC%94%E8%AF%95%E9%80%89%E6%8B%A9%E9%A2%98%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/",
            "title": "笔试选择题零散知识点--持续更新",
            "date_published": "2023-09-22T03:28:03.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>主要为了应付选择题一些极其细节的编程问题，还有一些范围很广的概念性问题，话不多说，直接开始</p>\n<h3 id=\"无标题\"><a class=\"markdownIt-Anchor\" href=\"#无标题\">#</a> 无标题</h3>\n<p>1、基础类型的使用：<br>\n必须赋初值，然后使用，不然直接报编译错误，无法通过编译。<br>\n但是引用类型或者数组就不一样，对于 new 的</p>\n<p>2、集合继承图<br>\n<img data-src=\"https://pic.imgdb.cn/item/650d122ac458853aef243cba.png\" alt=\"alt\"><br>\n 这边主要是将 map 记混了，以为都是继承的 collection，然后就是有一些线程安全的集合，vector、hashtable 以及 stack 是继承的 vector</p>\n",
            "tags": [
                "其他"
            ]
        },
        {
            "id": "http://example.com/2023/09/20/Redis%E7%BC%93%E5%AD%98/",
            "url": "http://example.com/2023/09/20/Redis%E7%BC%93%E5%AD%98/",
            "title": "Redis缓存",
            "date_published": "2023-09-20T14:23:45.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>一切都是为了更流利的表达</p>\n<h3 id=\"缓存雪崩-击穿-穿透的定义以及解决方案\"><a class=\"markdownIt-Anchor\" href=\"#缓存雪崩-击穿-穿透的定义以及解决方案\">#</a> 缓存雪崩、击穿、穿透的定义以及解决方案</h3>\n<h3 id=\"缓存同步策略\"><a class=\"markdownIt-Anchor\" href=\"#缓存同步策略\">#</a> 缓存同步策略</h3>\n<h3 id=\"高可用\"><a class=\"markdownIt-Anchor\" href=\"#高可用\">#</a> 高可用</h3>\n",
            "tags": [
                "Redis"
            ]
        },
        {
            "id": "http://example.com/2023/09/20/UF%E5%92%8CKruskal/",
            "url": "http://example.com/2023/09/20/UF%E5%92%8CKruskal/",
            "title": "UF和Kruskal",
            "date_published": "2023-09-20T09:55:31.000Z",
            "content_html": "<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] parent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ufInit</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        parent = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            parent[i] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">union</span><span class=\"params\">(<span class=\"type\">int</span> p, <span class=\"type\">int</span> q)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rootP</span> <span class=\"operator\">=</span> find(p);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rootQ</span> <span class=\"operator\">=</span> find(q);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rootP == rootQ) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        parent[rootP] = rootQ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent[x] != x) &#123;</span><br><span class=\"line\">            parent[x] = find(parent[x]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parent[x];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"comment\">//n is node num, k is edge num</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> sc.nextInt(), k = sc.nextInt();</span><br><span class=\"line\">        <span class=\"type\">Main</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Main</span>();</span><br><span class=\"line\">        m.ufInit(n);</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] edges = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[k][<span class=\"number\">3</span>];</span><br><span class=\"line\">        <span class=\"comment\">//input edge</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">            edges[i][<span class=\"number\">0</span>] = sc.nextInt();</span><br><span class=\"line\">            edges[i][<span class=\"number\">1</span>] = sc.nextInt();</span><br><span class=\"line\">            edges[i][<span class=\"number\">2</span>] = sc.nextInt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(edges, Comparator.comparingInt(a -&gt; a[<span class=\"number\">2</span>]));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span>[] edge : edges) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m.find(edge[<span class=\"number\">0</span>]) == m.find(edge[<span class=\"number\">1</span>])) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            m.union(edge[<span class=\"number\">0</span>], edge[<span class=\"number\">1</span>]);</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            sum += edge[<span class=\"number\">2</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count == n - <span class=\"number\">1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "算法"
            ]
        },
        {
            "id": "http://example.com/2023/09/19/dp%E7%BB%8F%E5%85%B8%E6%A8%A1%E6%9D%BF/",
            "url": "http://example.com/2023/09/19/dp%E7%BB%8F%E5%85%B8%E6%A8%A1%E6%9D%BF/",
            "title": "dp经典模板",
            "date_published": "2023-09-19T07:30:14.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>书接上回。主要写一下 dp 的大体思路，以及背包和股票。</p>\n<h3 id=\"dp思路\"><a class=\"markdownIt-Anchor\" href=\"#dp思路\">#</a> dp 思路</h3>\n<p>场景，涉及到最值，且存在状态转化的，这个时候可以考虑用 dp。当然也不要强行用，如果暴力可以直接 a 的话，就没必要炫技了。</p>\n<p>插一嘴，类似于什么前缀和什么的，感觉就是 dp，无差。</p>\n<h3 id=\"背包\"><a class=\"markdownIt-Anchor\" href=\"#背包\">#</a> 背包</h3>\n<p>直接上代码吧，主要使用一维的 dp 数组来做背包问题</p>\n",
            "tags": [
                "算法"
            ]
        },
        {
            "id": "http://example.com/2023/09/19/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%93%E9%A2%98/",
            "url": "http://example.com/2023/09/19/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%93%E9%A2%98/",
            "title": "算法总结专题",
            "date_published": "2023-09-19T05:56:39.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>最近笔试，有些题量大的，没有给你现场推导或者调试环境，这样的话，有些不熟悉但是很基本的算法，就会浪费很长的时间，以至于送分的拿不到，所以对于一些我自己熟悉的或者不熟悉的都需要整合，以提高速度。</p>\n<h3 id=\"思维风暴\"><a class=\"markdownIt-Anchor\" href=\"#思维风暴\">#</a> 思维风暴</h3>\n<p>也没列什么框架，目前就是打算直接将自己的想法具象化，留痕并且加深印象，话不多说，直接开始。</p>\n<p>对于核心代码模式，没什么可说的，感觉核心代码模式难度可能会上去点，也会涉及到题目给到的数据结构（treenode，listnode 等等），也更偏向于我们平时力扣的 coding 风格，所以会的会，不会的应该也不会了。</p>\n<p>对于 acm 模式，牛客和赛马平台，主要就是在于输入的接收，这个时候要淡定，好的习惯是先接收然后 sout 一下，看一下到底是什么，然后继续解题，比如我第一次做赛马，小米给的输入是 string，需要自己切分来处理数据，没经验，加上自我怀疑，就笔试很不理想。<br>\n对于 acm 来说，我觉得需要注意的就是图和树了，树的话也算是图的一种形式吧，应该以 edge 的方式接收多一点，也就是 int [] 两个节点。图的话需要进一步整合才能做分析，或者直接暴力接收，然后做题，也行，不要畏惧就是了。<br>\n对于图的话，用邻接表接个人觉得好一点，然后就相当于处理一个二维数组，dfs 可以解决，如果超时的话，就需要换图算法了。</p>\n<p>最近打算回顾两类算法，dp 的背包和股票、图的并查集 uf，kruskal，prim 以及 dijkstra</p>\n<p>具体放在下面的 blog 中，冲！</p>\n",
            "tags": [
                "算法"
            ]
        },
        {
            "id": "http://example.com/2023/09/14/%E9%87%8D%E5%86%99equals%E5%92%8Chashcode/",
            "url": "http://example.com/2023/09/14/%E9%87%8D%E5%86%99equals%E5%92%8Chashcode/",
            "title": "重写equals和hashcode",
            "date_published": "2023-09-14T13:33:23.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>一切为了手撕！</p>\n<h3 id=\"话不多说\"><a class=\"markdownIt-Anchor\" href=\"#话不多说\">#</a> 话不多说</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String b;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">char</span>[] c;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object o)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> == o) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"literal\">null</span> || getClass() != o.getClass()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"type\">Solution</span> <span class=\"variable\">other</span> <span class=\"operator\">=</span> (Solution) o;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a == other.a &amp;&amp; Objects.equals(b, other.b) &amp;&amp; Arrays.equals(c, other.c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> Objects.hash(a, b);</span><br><span class=\"line\">        result = <span class=\"number\">31</span> * result + Arrays.hashCode(c);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实也没啥好讲的，直接从两个函数分开讲吧。</p>\n<p>首先，hashcode 相等，两个对象不一定相等。equals 相等，hashcode 一定要想等。我们一般重写这两个的目的，就是为了去重，合理的判断两个自定义的对象是否相等。</p>\n<h3 id=\"equals\"><a class=\"markdownIt-Anchor\" href=\"#equals\">#</a> equals</h3>\n<p>主要就是四步：<br>\n第一步，看看是否同一对象，是的话还判断啥，直接 true。<br>\n第二步，看看是否为 null，或者所属类是否一样，有一个满足，直接 false。<br>\n第三步，强转，都是同一个类了，直接强转，好进行最后的操作。<br>\n最后，return 直接用 Objects.equals () 或者 Arrays.equals () 来比较，全部用 &amp;&amp; 连接，一个不满足就 false。</p>\n<h3 id=\"hashcode\"><a class=\"markdownIt-Anchor\" href=\"#hashcode\">#</a> hashcode</h3>\n<p>主要还是靠 Objects 和 Arrays 两个工具类，这两个工具类分别针对数组和一般对象，可以直接生成 hashcode。但是如果两个同时存在，需要借助 31 这个特殊的参数，这个参数感觉也是实验数据，也有的解释就是 2^5-1。感觉还是实验获得比较合理一些。<br>\n两者相加即可</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/09/14/Explain%E5%92%8C%E7%B4%A2%E5%BC%95/",
            "url": "http://example.com/2023/09/14/Explain%E5%92%8C%E7%B4%A2%E5%BC%95/",
            "title": "Explain和索引",
            "date_published": "2023-09-14T13:31:27.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>从原先的 “原来还能通过 explain” 查看 sql 的运行效率，到 “请你讲讲 explain 中的各个字段”，再到 “解释一下 extra 字段的值的含义以及效率排序”，一脸懵，不学不行啊，记录一下呗。</p>\n<h3 id=\"explain\"><a class=\"markdownIt-Anchor\" href=\"#explain\">#</a> Explain</h3>\n<p>当需要查看一下当前 sql 在 mysql 中的运行状态时（这个状态包括一些执行时间，是否使用索引，检索的表，检索字段大小）等等，主要还是针对一些其中的字段值，来判断如何进一步优化 sql。</p>\n<p>说实话，explain 很复杂，没太整明白。主要就说一些自己整明白的点吧</p>\n<p>ID：如果存在多个 select 的话，那么 id 就会有多个值，id 值越大，表示优先级越高。</p>\n<p>select_type：查询类型，也就是存在多个 select 的时候，这个时候就会有不同的类型出现，整明白的也就几个吧：</p>\n<ul>\n<li>simple，表示最简单的查询，无嵌套</li>\n<li>primary，最外层的查询</li>\n<li>union，用 union 接的查询；也不是百分百，如果接在子查询里面，那么貌似第一个是 derived</li>\n<li>derived，子查询</li>\n</ul>\n<p>table：查询的表</p>\n<p>type：连接类型，也就是存在级联查询中，下面按照关键字优先级展开简单讲讲每个关键字吧：</p>\n<ul>\n<li>system，个人感觉不太存在，也就是这个表只有一行，emmm 太抽象</li>\n<li>const，针对主键或唯一建的查询，只返回一行，比较好理解</li>\n<li>eq_ref，使用了索引的全部组成，并且索引是主键或者唯一键，也好理解</li>\n<li>ref, 不是很懂，貌似是用到了索引，但是没有主键索引和唯一键索引</li>\n</ul>\n<p>range：范围查询涉及到的字段，关键字貌似就两个 index 和 all，很明显一个用到了索引，另一个全表扫描，如果全表的话，就需要反思一下了</p>\n<p>possible_key 和 key：这两个放一起讲好了，也就是有的索引和用到的索引，没什么好讲的。</p>\n<p>key_len：索引字段长度，没什么好讲的</p>\n<p>rows：估计会扫描的行数，值越小越好</p>\n<p>extra：额外信息，感觉和前面给到的信息有点重，但是可能是针对不同场景的，下面有些字段要说明一下：</p>\n<ul>\n<li>using filesort，文件排序，sql 中包含 order by，然后索引不足以解决 order，那么 mysql 会选择使用内存，超过一定长度就磁盘，这种情况就是这个字段。</li>\n<li>using temporary，临时表，sql 中包含 group by，这个时候索引不足以解决问题，那么就会借助临时表来完成</li>\n<li>using index，使用索引可以解决，</li>\n<li>using where，满足部分的索引，也就是使用了，但没完全使用，比如仅满足</li>\n</ul>\n",
            "tags": [
                "MySQL"
            ]
        },
        {
            "id": "http://example.com/2023/09/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%EF%BC%89/",
            "url": "http://example.com/2023/09/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%EF%BC%89/",
            "title": "设计模式（从代码层面）",
            "date_published": "2023-09-14T13:21:24.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>写这篇也是为了手撕，还有就是加深一下对设计模式的理解吧。</p>\n<p>缘由：得物手撕单例模式，虽然了解之后挺简单的，但是当时就是不会，so</p>\n<h3 id=\"单例模式\"><a class=\"markdownIt-Anchor\" href=\"#单例模式\">#</a> 单例模式</h3>\n<h4 id=\"饿汉模式\"><a class=\"markdownIt-Anchor\" href=\"#饿汉模式\">#</a> 饿汉模式</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">INSTANCE</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总的来说，饿汉模式，就是只要类加载，那么就会有一个单例出现，就像是只要有东西，我就抢一样，“饿汉”—— 很形象。<br>\n那么其中要注意个点，就是将 instance 放在 static 中，让类加载就生成就完事。并且构造函数一定要是私有的，不然外面就可以 new 了。一定要让他们通过 get 获取实例，保证唯一。</p>\n<h4 id=\"懒汉模式\"><a class=\"markdownIt-Anchor\" href=\"#懒汉模式\">#</a> 懒汉模式</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>懒汉模式，也很简单。顾名思义，并不是类加载就给 new 一个，而是当用到的时候才 new 一个，所以它很懒。就是其中引入了 null，判断，然后给 new 或者返回。<br>\n线程不安全，解释一下啊。就是 a，b 同时进入到 if 判断，那么这个时候两个线程同时测到 null，就会同时执行 new。所以就是多个实例，违背了单例，所以线程不安全，也就是存在竞争呗，简单的解决方法就是上锁，synchronized。<br>\n可以给 get 上锁，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span></span><br></pre></td></tr></table></figure>\n<p>也可以给 new 这个代码块上锁，但是代码快上锁有问题，所以就产生了 DCL。上面也有效率问题，也就是每个线程 get 的时候，都要上锁，很慢。</p>\n<h4 id=\"dcl双重锁定检查\"><a class=\"markdownIt-Anchor\" href=\"#dcl双重锁定检查\">#</a> DCL 双重锁定检查</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很经典啊。<br>\n首先，引入 volatile 关键字，虽然我也不动为什么要引入，感觉 static 一样的。<br>\n其次双重判断，如果 null，那么上锁 new，并且如果 a，b 同时进入上锁，那么只有一个能拿到，并且 a 如果拿到，且 new 了；那么 b 就会进入第二层判断，此时不为 null，那么退出，直接拿实例走人。双重保险，很合理。<br>\n第一层判断是为了防止后面的 get 都上锁，加快了速度；第二层上锁，是为了防止重复 new，保证了单例。<br>\n经典。</p>\n<h4 id=\"静态内部类\"><a class=\"markdownIt-Anchor\" href=\"#静态内部类\">#</a> 静态内部类</h4>\n<p>这个我也懂，代码明天更，也就是将 new 放到了里面一层，没什么高深的</p>\n<h4 id=\"枚举\"><a class=\"markdownIt-Anchor\" href=\"#枚举\">#</a> 枚举</h4>\n<p>没整明白，看起来挺叼的</p>\n<h3 id=\"策略模式\"><a class=\"markdownIt-Anchor\" href=\"#策略模式\">#</a> 策略模式</h3>\n<h4 id=\"使用场景\"><a class=\"markdownIt-Anchor\" href=\"#使用场景\">#</a> 使用场景</h4>\n<p>看了一些网上使用策略模式的场景，有一些感悟。<br>\n试想一下有 20 条 if else，此时，需要你来扩展第 21 条，是不是头皮发麻，没错，策略模式可以拯救你。<br>\n所以策略模式就是将业务代码和逻辑代码解耦，方便使用以及扩展。</p>\n<p>具体由三个部分组成 strategy，具体的 strategy 以及策略的使用场景 context</p>\n<p>话不多说，直接上代码</p>\n<h4 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h4>\n<p>主要三块</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// strategy</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">AttackStrategy</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">attack</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// specific strategy</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MeleeAttackStrategy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">AttackStrategy</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">attack</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;近战攻击&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RangedAttackStrategy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">AttackStrategy</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">attack</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;远程攻击&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// context</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Character</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> AttackStrategy attackStrategy;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAttackStrategy</span><span class=\"params\">(AttackStrategy attackStrategy)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.attackStrategy = attackStrategy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">attack</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        attackStrategy.attack();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// use</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Character</span> <span class=\"variable\">character</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Character</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//这一块就相当于之前的if else了，直接交给context来判断</span></span><br><span class=\"line\">        character.setAttackStrategy(<span class=\"keyword\">new</span> <span class=\"title class_\">MeleeAttackStrategy</span>());</span><br><span class=\"line\">        character.attack(); <span class=\"comment\">// 输出：近战攻击</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        character.setAttackStrategy(<span class=\"keyword\">new</span> <span class=\"title class_\">RangedAttackStrategy</span>());</span><br><span class=\"line\">        character.attack(); <span class=\"comment\">// 输出：远程攻击</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"工厂模式\"><a class=\"markdownIt-Anchor\" href=\"#工厂模式\">#</a> 工厂模式</h3>\n<h4 id=\"背景\"><a class=\"markdownIt-Anchor\" href=\"#背景\">#</a> 背景</h4>\n<p>首先说一下为什么要用工厂模式，也就是使用的场景：<br>\n对于我们平时见到的 A a = new A (); 这样的对象创建，我觉得除了说对象的创建和 client 耦合在一起了，其他的感觉用工厂就是脱裤子放屁。<br>\n但是并不是所有的对象创建都是如此的简单的，比如创建一个复杂的对象，需要做一些验证，或者需要很多的参数等等，那么这个时候就会很麻烦。应用到现实生活中就是，对于简单的小玩意，我可以自己搞搞，然后用。但是对于汽车，飞机，我只是想用一用，你让我自己去造，不开玩笑么，所以交给工厂就好。</p>\n<p>现在说一下工厂模式的意义，</p>\n<ul>\n<li>解耦，解什么耦，创建和使用的耦合，我只关心使用，而不关心创建</li>\n<li>解耦就会导致什么，代码复用麻，所以就避免了多次创建的冗余的代码</li>\n</ul>\n<p>感觉主要就这两点吧，其余的没啥好说的。</p>\n<h4 id=\"代码实现-2\"><a class=\"markdownIt-Anchor\" href=\"#代码实现-2\">#</a> 代码实现</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如果让我手撕的话，那么主要就是工厂类和产品类，两个都要接口或者说抽象类；然后工厂类有A B，产品类有a b；工厂A能成产a b，工厂B也能生产a b；感觉就是有点像抽象工厂</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//factory</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Factory</span> &#123;</span><br><span class=\"line\">\tPhoneProject <span class=\"title function_\">projectPhone</span><span class=\"params\">()</span>;</span><br><span class=\"line\">\tLaptopProject <span class=\"title function_\">projectLaptop</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//specific factory</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HuaWeiFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Factory</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> PhoneProject <span class=\"title function_\">projectPhone</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HuaWeiPhone</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> LaptopProject <span class=\"title function_\">projectLaptop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HuaWeiLaptop</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XiaomiFactory</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Factory</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> PhoneProject <span class=\"title function_\">projectPhone</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XiaomiPhone</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> LaptopProject <span class=\"title function_\">projectLaptop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XiaomiLaptop</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//此处省略产品的接口和实现类</span></span><br><span class=\"line\">。。。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">PhoneProject</span> <span class=\"variable\">huawei</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HuaWeiFactory</span>().projectPhone();</span><br><span class=\"line\">\t\thuawei.printInfo();</span><br><span class=\"line\">\t\thuawei.getId();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"type\">PhoneProject</span> <span class=\"variable\">xiaomi</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">XiaomiFactory</span>().projectPhone();</span><br><span class=\"line\">\t\txiaomi.printInfo();</span><br><span class=\"line\">\t\t<span class=\"type\">LaptopProject</span> <span class=\"variable\">huawei1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HuaWeiFactory</span>().projectLaptop();</span><br><span class=\"line\">\t\thuawei1.printInfo();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结一下上面的代码，总的来说也没什么高深的，也就是将 factory 抽象了一下，然后有几个工厂实现类，调 produce 生产产品；感觉就是这样。</p>\n<h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>目前感觉掌握了这几个设计模式吧，其实也没那么高深；<br>\n最好理解的当然是单例了，也就是防止对象被多次创建，spring 里面就是限制了单例，会个 DCL 感觉就差不多了。<br>\n对于策略和工厂的话，总感觉很相似，但是也就是实现的思路其实差不多的，都是解耦，然后使用的话也是让策略或者工厂去选择。<br>\n从具体的目的使用来说的话，两者区别还是很大的</p>\n<ul>\n<li>对于策略来说，主要解耦的是逻辑代码和业务代码。其目的是为了给出策略，也就是选择。它主要的三个 strategy，impl 和 context。也就是抽象实现，但是具体的再 context 里面吧，通过对象传进来然后赋值给抽象 strategy，后面直接用 context 来调方法，完成逻辑解耦。</li>\n<li>对于工厂来说，主要解耦的是对象的创建和使用。其属于创建型设计模式。主要的也就是 factory，impl；product，impl；只要有工厂的实例，或者静态类，就直接可以创建一些复杂对象，完成解耦。</li>\n</ul>\n<p>感觉也没什么复杂的，放宽心。</p>\n",
            "tags": [
                "设计模式"
            ]
        },
        {
            "id": "http://example.com/2023/09/14/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/",
            "url": "http://example.com/2023/09/14/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/",
            "title": "常见排序总结（为了手撕）",
            "date_published": "2023-09-14T12:58:06.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>总结一下常见的排序，主要以记录为主。排版就直接上代码 + 个人理解的思路。并且是本人习惯的编码风格。主要是为了防止手撕遇到，不然真不想总结这玩意…</p>\n<h3 id=\"冒泡\"><a class=\"markdownIt-Anchor\" href=\"#冒泡\">#</a> 冒泡</h3>\n<p>冒泡不打算上代码，直接讲个思路。<br>\n两层 for，以升序为例，每轮选最小的放前面，或者最大的放后面。<br>\n两两相邻比较，大的往后移即可。</p>\n<h3 id=\"选择\"><a class=\"markdownIt-Anchor\" href=\"#选择\">#</a> 选择</h3>\n<p>选择也一样不上代码，跟冒泡类似，只不过冒泡是每次都 swap，而选择是以 temp 记录每一轮的最大数，然后最后进行 swap 即可</p>\n<h3 id=\"快排\"><a class=\"markdownIt-Anchor\" href=\"#快排\">#</a> 快排</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">quicksort</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left &gt;= right) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        swap(nums, random.nextInt(right-left+<span class=\"number\">1</span>)+left, left);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sentinel</span> <span class=\"operator\">=</span> partition(nums,left, right);</span><br><span class=\"line\">        quicksort(nums,left, sentinel -<span class=\"number\">1</span>);</span><br><span class=\"line\">        quicksort(nums, sentinel +<span class=\"number\">1</span>, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">partition</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> left;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= nums[temp]) right--;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= nums[temp]) left++;</span><br><span class=\"line\">            swap(nums,left, right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(nums, temp, right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> nums[left];</span><br><span class=\"line\">        nums[left] = nums[right];</span><br><span class=\"line\">        nums[right] = temp;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码是加入了 random 的写法，目的是防止了一些极端的情况。说一下思路</p>\n<p>选择一个基准的 num，然后对左右两边再进行快排，明显是个分治（递归）。</p>\n<p>那么就是这个基准如何去找，单独拉出一个 partition 函数，以最左边的 num 为基准，左右两个指针 left 和 right 同时找小于等于和大于等于他的。注意，这里的等于要带上，不然会死循环，也就是 left 和 right 会不往中间走。需要注意的点就是 right 在前，不然会出现最终的位置错误。</p>\n<p>最后替换的那个 num 就是后续的切分点。</p>\n<h3 id=\"插入排序\"><a class=\"markdownIt-Anchor\" href=\"#插入排序\">#</a> 插入排序</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">InsertSort</span><span class=\"params\">(<span class=\"type\">int</span> arr[])</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; len; i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> arr[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> j;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j = i-<span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j] &gt; tmp)&#123;</span><br><span class=\"line\">               arr[j+<span class=\"number\">1</span>] = arr[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[j+<span class=\"number\">1</span>] = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>网上找的代码，具体没写过，直接说一下思路。</p>\n<p>插入的思想就是跟打牌抓牌，然后整理牌一样。</p>\n<p>两层 for，第一层相当于抽牌。第二层相当于找插入点。具体的思路就是将当前的牌的位置空出来，用 temp 接一下，升序的话就是大于当前牌的 num 往后移，否则退出循环，将 temp 插入到退出的那个点即可。</p>\n<p>优化：也就是利用的插入的特点吧，手里的牌必然是有序的，所以查找插入点可以用二分，所以会进一步降低复杂度。</p>\n<h3 id=\"希尔排序\"><a class=\"markdownIt-Anchor\" href=\"#希尔排序\">#</a> 希尔排序</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">shellSort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr == <span class=\"literal\">null</span> || arr.length &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">gap</span> <span class=\"operator\">=</span> arr.length / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (gap != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> arr[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i - gap;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; value; j -= gap) &#123;</span><br><span class=\"line\">                arr[j + gap] = arr[j]; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr[j + gap] = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        gap /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>网上考的代码，具体我也没写过。说一下具体的思路。</p>\n<p>大体的思路就是，分组进行插入排序，通过不断的缩小这个分组的长度来达到整体的排序效果。</p>\n<p>编码的思路和实际的讲解思路稍微有点不一样。讲解思路是对每一组进行插入排序，但是编码的思路是每次仅完成每一组的一个元素的位置寻找。说的形象一点就是，当前如果是第一组的第二个元素插入，那么 i 的下一轮就是第二组的第二个元素的插入，所以稍微有点不一样，看代码就知道了 i++，插入的话，j 是 j-gap 跳着找。没有图还是比较抽象，，，</p>\n<h3 id=\"堆排\"><a class=\"markdownIt-Anchor\" href=\"#堆排\">#</a> 堆排</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">heapsort</span><span class=\"params\">(<span class=\"type\">int</span> n[])</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> n.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">        buildHeap(n, i);</span><br><span class=\"line\">        swap(n, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buildHeap</span><span class=\"params\">(<span class=\"type\">int</span> n[], <span class=\"type\">int</span> end)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> end + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> len / <span class=\"number\">2</span> - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> <span class=\"number\">2</span> * i + <span class=\"number\">1</span>, r = l + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> l;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r &lt;= len - <span class=\"number\">1</span> &amp;&amp; n[l] &lt; n[r]) &#123;</span><br><span class=\"line\">            p = r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n[i] &lt; n[p]) &#123;</span><br><span class=\"line\">            swap(n, i, p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接贴的网上的代码，应该是教科书代码。具体的思路如下：</p>\n<p>堆排的最直观的思路是，加入是大顶堆，每次能取到最大的元素，将这个最大的元素摆放在最后的位置即可，重点在于怎么写这个大顶堆，这边看的时候也是刷新了一下思维。</p>\n<p>一直以为像堆这种的树结构，都是 treenode 节点，通过指针来跳的，但是那样的话就会很难写。以前一直不知道这个堆该怎么手撕，现在看上面的代码。</p>\n<p>heapsort 是整体的结构，每次取 i-n 的元素进行重新的堆排，而排好的，也就是堆顶，放到末尾。</p>\n<p>buildheap 就是如何调整这个堆的，很神奇。这边有一些我认为的先验知识，首先堆的起始点是 n/2，因为是完全二叉树，所以有子节点的最后一个节点必然是 n/2 的位置。其次如果当前节点为 i ，那么其子节点就是 2i 和 2i+1，所以将 i 和 2i 与 2i+1 比较，找出最大的然后 swap 即可（注意：上面的代码是从 0 下标开始的，也就是没有做处理，我看有的讲解是将第一个位置空出来，然后下标就可以和我上面的对上；但是上面的代码更实际，也就是统一 -1）</p>\n<p>​\t上面这个 buildheap 代码思路，就是判断是否有右子树，有的话，标出大的那个，如果根节点小于大的那个，那么就换上去，依次类推，十分简单，堆就构造完了。</p>\n<h3 id=\"归并排序\"><a class=\"markdownIt-Anchor\" href=\"#归并排序\">#</a> 归并排序</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span>[] sortArray(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(left == right) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;nums[left]&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> merge(sortArray(nums,left,mid),sortArray(nums,mid+<span class=\"number\">1</span>,right));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span>[] merge(<span class=\"type\">int</span>[] leftArr, <span class=\"type\">int</span>[] rightArr)&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[leftArr.length + rightArr.length];</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, right = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; res.length; i ++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left &gt;= leftArr.length) res[i] = rightArr[right++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(right &gt;= rightArr.length) res[i] = leftArr[left++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(leftArr[left] &lt; rightArr[right]) res[i] = leftArr[left++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> res[i] = rightArr[right++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分治思想，有点和快排类似，但是归并比快排更稳定，也就是当纯倒序，快排会退化成 O (n^2)。</p>\n<p>这是之前写的代码，也就是一贯的风格，用 int [] 来接，并且用 split 和 merge 两个组成归并排序。</p>\n<p>大体的思路就是不停的切，每次找 num 的 mid，切开；left 到 mid，mid+1 到 right；也很简单，split 不用说了，就是找 mid，切开；merge 的话就是合并两个有序的数组，很简单。</p>\n<h3 id=\"基数排序\"><a class=\"markdownIt-Anchor\" href=\"#基数排序\">#</a> 基数排序</h3>\n<p>简单说一下，并没有细看<br>\n说使用的桶思想，每一轮使得每一位有序。</p>\n<h3 id=\"稳定性\"><a class=\"markdownIt-Anchor\" href=\"#稳定性\">#</a> 稳定性</h3>\n<p>这边讲一下稳定性，稳定性的意思并不是最好和最坏的时间复杂度一样，而是对于相同的两个元素，排完序后他们的相对位置总是保持不变的。<br>\n所以基于上面的定义，那么稳定的排序算法不会改变相同元素的相对位置。直接给结论，不稳定的排序算法有：</p>\n<ul>\n<li>快排，sentinel 的选择</li>\n<li>选择</li>\n<li>堆</li>\n<li>希尔</li>\n</ul>\n<h3 id=\"空间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#空间复杂度\">#</a> 空间复杂度</h3>\n<p>也没有细看，目前就直接记不是 O (1) 的算法：</p>\n<ul>\n<li>快排</li>\n<li>归并</li>\n<li>基数、桶、计数（三个桶都是 n+k）</li>\n</ul>\n<h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>以上就是我接触的常见的排序了，感觉也是了结了一个心事。其中常写的就是快排和归并，总结一下就是很简单，也就这两个我贴的我自己的代码风格。</p>\n<p>欧凯，结束，排序了结，希望手撕到这种题目的时候我可以秒斯，yes</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/09/14/%E8%AE%A9%E8%87%AA%E5%B7%B1%E6%85%A2%E4%B8%8B%E6%9D%A5/",
            "url": "http://example.com/2023/09/14/%E8%AE%A9%E8%87%AA%E5%B7%B1%E6%85%A2%E4%B8%8B%E6%9D%A5/",
            "title": "让自己慢下来",
            "date_published": "2023-09-14T11:10:06.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>工作难找，* 难吃，欸</p>\n<h3 id=\"新阶段\"><a class=\"markdownIt-Anchor\" href=\"#新阶段\">#</a> 新阶段</h3>\n<p>所谓厚积薄发，书到用时方恨少。所以，在大火都着急 offer 的时候，我打算稳住自己的节奏，缓步推进学习计划。<br>\n俗话说的好，最大的敌人就是你自己。不能自乱阵脚，只要我在进步，那么总有接近目标的一天，yes</p>\n<h3 id=\"计划\"><a class=\"markdownIt-Anchor\" href=\"#计划\">#</a> 计划</h3>\n<p>频繁且少量的更新自己的知识点，虽然网上都有，但这也就是类似于默写吧，加深记忆。<br>\n自己的理解，所以可能有错误。<br>\npeace &amp; love</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/18/%E5%AE%9E%E4%B9%A0%E6%B1%87%E6%80%BB/",
            "url": "http://example.com/2023/07/18/%E5%AE%9E%E4%B9%A0%E6%B1%87%E6%80%BB/",
            "title": "实习汇总",
            "date_published": "2023-07-18T11:10:06.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>本篇是技术文。<br>\n实习以来，接触了很多的东西，下面从几个方面简单罗列一下：</p>\n<ul>\n<li>语言：Java、Python</li>\n<li>框架：SpringBoot、Hibernate、Mybatis、Django</li>\n<li>数据：MySQL、Milvus、ElasticSearch、Ceph<br>\nPS：Ceph 分布式存储，我不知道应不应该这么分类，在公司的具体的用法就是通过 Swift/S3，与分布式存储系统进行交互，具体的业务就接触过上传附件。还有很多其他的东西，我不知道该怎么分类，我想把他们分为工具的，但是总感觉不合适，可能是因为没弄懂，确实是没弄懂，后面单独讲。</li>\n</ul>\n<h3 id=\"粗略的过一下\"><a class=\"markdownIt-Anchor\" href=\"#粗略的过一下\">#</a> 粗略的过一下</h3>\n<p>这篇我没有详细的框架，但是有个很明确的想法（串一下目前接触到的技术），所以肯定全部是略讲。<br>\n串的话，我主要打算按照时间线来，回顾一下两个月接触到的各种工具、技术…</p>\n<h4 id=\"单元测试\"><a class=\"markdownIt-Anchor\" href=\"#单元测试\">#</a> 单元测试</h4>\n<p>刚开始来的时候，我主要是写 Junit 来熟悉组内接手的业务，这边先是写的 Java 项目的单元测试，后面又写了 Python 的单元测试。<br>\n对于 Java 而言，组内使用的框架是 Junit+PowerMockito。这边讲一下单元测试主要的思想：检验代码逻辑，按照软件工程的概念，就是对于业务代码的测试，也属于最底层的测试了，所以一般是由程序员编写测试用例。组内使用的框架是 Junit+PowerMockito，感觉主要的还是 mock，也就是所谓的打桩（模拟）。通过模拟当前程序之外的对象 / 函数，来检验逻辑的正确性。Java 主要就是通过 PowerMockito 来模拟对象，以及对象的行为。其中印象比较深刻的点在于可变参数方法的 mock、多线程 mock 以及有无返回值方法的 mock，其他的感觉都是一些正常的 mock。<br>\n对于 Python 而言，和 Java 对应的话，就是 TestCase+mock。接触的 Junit 是基于 Django 写的后端的前台管理，使用的是 Django 内部的 TestCase+Python 的 Patch+MagicMock。测试类继承 TestCase，使用 @patch 来模拟方法以及 MagicMock 来模拟对象。@patch 相当于注入，MagicMock 相当于 new，可以简单的这么理解。其中印象深刻的点在于，@patch 注入和方法中的参数是相反的（这边描述的很抽象，我也没截图，大概只有我自己能看懂）、需要额外定义 side_effect 函数，并且传给 mock 对象的 side_effect 属性，来模拟对象的行为、Python 中比较抽象的在于它 @patch 传入方法不是对象，这个 Java 相比还是很大区别的，当时也被坑了好久，其他的感觉也就正常吧，主要是和 Java 有很多不一样的点。<br>\nPS：其中对于测试用例的书写，大致是通过数据库表结构或者代码中用到的属性来 mock；正规是要最后使用 assert 来断言，但是我目前还没体会到这个 assert 的作用，总感觉不好用；不太科学的衡量标准，检测当前 UT 的标准是覆盖率。</p>\n<h4 id=\"项目开发\"><a class=\"markdownIt-Anchor\" href=\"#项目开发\">#</a> 项目开发</h4>\n<p>其一，完整的项目开发就是公司提供的 MIT，针对校招生的开发实践，目的主要是为了熟悉公司的工具和框架吧。<br>\n这个项目非常的完整，从 0 开始，需要申请 App ID，走公司的流水线平台。这个 App ID 就是公司识别项目的唯一标志。流水线的话，可以理解为一条龙吧，主要是 CI/CD（持续集成）。这边有很多的概念，我主要讲一下这流水线中涉及到的东西吧。将 Git 与 CI/CD 工具关联（公司平台做了），当 push 的时候，自动生成对应的镜像，平台可以配置集群（针对项目，也就是项目可以部署在多个服务器上，可以做一些访问限制以及负载均衡），很多功能，更多的是作为一个工具，这个平台也就是将项目开发部署和维护都交给程序员了，这也是 CI/CD 的核心理念吧。申请 App ID 之后，就相当于有了一个通行证吧，然后通过公司的脚手架创建 SpringBoot Web 项目。通过脚手架创建的好处，就是公司内部的一些默认配置会给你设定好。这边就涉及到公司使用的 BOM（写在 POM 中，公司内部的 Jar 包版本管理，原理没有了解过），其作用相当于<dependencyManagement>，后续使用公司内部的 Jar 包就不需要指定版本了，也避免了一些版本冲突。从数据说起的话，就是题目提供的 mysql 和 Redis，两个都是公司建好的集群（公司内部一般数据都是统一化管理，并且封装一层访问方式，为了避免密码的配置）。公司通过 DAL（应该是公司内部封装的 mysql 的连接方式）建立与 mysql 的数据连接，Redis 的话是直接调的公司的 Jar 包。当然要配置 SqlSession，也就是这边深刻理解了 bean 的注入，对于以上两者都需要进行 config 的注入，将数据连接交给 spring 管理。Redis 比较简单的使用，mysql 的话，还需要使用 JPA 规范，这里使用的是 Mybatis Plus，这边深刻理解了 Mybatis Plus 对于 SqlSession 的封装注入，与 Mybatis 还是不一样的。然后就是做一些基础的 CRUD 了。<br>\n除了基本的业务之外，这里面增加了很多其他的东西：QMQ 消息的收发（公司内部也封装了消息中间件，个人感觉就是集群化了）。通过 Baiji 规范写 SOA 服务，并且发到公司内部的 SOA 平台上，通过 Client 实现并调用（跟 Jar 包一样）。VI 点火，也就是项目启动的时候，需要验证是否满足项目启动的标准，当然可以在项目启动之前做一些操作，比如资源的加载什么的。重量级的就是 log 埋点了，出 bug 才知道日志的重要性。所以公司有很多关于日志的平台 CLog、Cat、Dashboard…，公司内部封装很多工具，将 @slf4j 生成的 log 直接上传到 log 管理平台，提供日志分析等等。深刻体会日志埋点的重要性。<br>\nPS：这个学到了很多的东西，除去熟悉了公司的工具和技术架构之外，从头到尾捋顺了项目的开发。建立了一个比较规范的包结构。深入理解了对象注入。</p>\n<p>其二，非完整项目开发，也就是对已有项目修改，或者开发一些新的接口。<br>\n第一个场景是合并带有时间戳的数据库记录，类似于交并集的算法题。说的专业点的话，就是先 sort，使用贪心进行记录的合并。基本和算法题一模一样，只是涉及了一点业务背景，其中涉及到对象解包，也就是将内部封装好的 DTO 对象，通过 BeanUtil 拆解为 map 集合，然后再添加一些新的键值对，返回给前端。上次用的 apache 的 BeanUtil，但是建议貌似使用 mapstruct 比较好一点。第二个场景与 ElasticSearch 相关，其实需求很简单，就是根据用户当前的状态信息，筛选 es 上的数据。了解了 es 的数据结构，一如既往，对于数据库而言，肯定有配套的语句，而最难的肯定是 select。对于 es 也一样，我大部分经历也是在学习它的语法，后面会有专门的文章来分享一下 es，从搭建到检索。这个项目并没有使用目前现有的工具，历史原因吧可能，直接使用的 template 模板文件来生成语句（这边提一嘴，这也就是底层吧，比如使用其他的工具的时候，就是对于这个模板语句的生成做了封装），这边学到的点就是对于 freemarker 这类的模板工具有了深刻的理解，后面也打算深入学习一下，然后搞一篇。第三个场景是附件上传，这边接触到了 Ceph，两类访问方式吧（Swift 和 S3），目前只知道这是个分布式的存储系统，实现的话也是通过 Swift/S3 连接服务器，然后上传的话，直接返回一个 URL，可以直接以 get 方式下载资源。实现也很简单吧，但是里面的东西还是很多的。一个是了解了 Session 和 Cookie，因为 Session 是服务端加工的，一般要 setAttribute，所以对于 controller 拿数据的时候，@requstParam 和 @requestAttribute 还是不一样的，细品，反正我经过这个接口直接深入体会。还有的话就是这里的一个工程性的点，一般对于这个需求的话，我直接上传返回 URL 直接就结束了，但是我从佳文那里学到的点就是，本地需要建立一张附件信息表，记录上传的附件信息，是不是很有必要！</p>\n<h4 id=\"结尾\"><a class=\"markdownIt-Anchor\" href=\"#结尾\">#</a> 结尾</h4>\n<p>说实话，真的很难写。<br>\n一个是我的语言表达一向有很大的问题，二者确实脑子现在很混乱，有很多就没有理清楚…<br>\n 所以我也就抱着记录一下的心态来写，主要是记录一下涉及到的知识点吧，后面理清楚一点再重新写这篇，并且其中也埋下了很多技术坑，不知道有生之年能不能填上。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/15/%E7%95%85%E6%83%B3/",
            "url": "http://example.com/2023/07/15/%E7%95%85%E6%83%B3/",
            "title": "畅想",
            "date_published": "2023-07-15T08:38:28.000Z",
            "content_html": "<p><img data-src=\"https://i.imgtg.com/2023/07/15/OzdvOt.png\" alt=\"Alt Text\"></p>\n<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<blockquote><p>天不生我大白鹅，画界万股如长夜！</p>\n<footer><strong>——毕加索</strong></footer></blockquote>\n<p>咳咳，如大家所见，鄙人走的抽象派…<br>\n 今天我们就来纸上谈兵一手，分析一下，如何靠的一张嘴，搭建一个前后端系统。</p>\n<h3 id=\"系统架构\"><a class=\"markdownIt-Anchor\" href=\"#系统架构\">#</a> 系统架构</h3>\n<p>先是自身的想法，我想将这个静态的博客，搭建成一个前后端分离的博客系统。为什么这么想呢，主要有几个原因：<br>\n其一，实习学到的一点技能，想找个地方挥霍一把。<br>\n其二，就想拆一下这个 hexo 搭建的静态 page<br>\n 其三，很主要的原因，主要是不想写论文，找点喜欢的事做做…</p>\n<p>可以从图上得知，本人的画技如此的滑稽…，<br>\n可以从上图得知，我想将 Hexo 作为一个只生成博客的空壳，将数据从里面分离出来，持久化到 mysql，然后通过后端的 API，将数据返回给前端，这样就前后端分离了。那么能不能有个发布博客的后台呢，以及统计一些数据、展示图表的后台呢，我觉得可以有，这样直接就可以线上，可以线下了，岂不美滋滋。</p>\n<p>大体而言，外面能看到的，也就是域名能够访问到的，当然还是和之前一样，只有博客。我目前还没有完全想好这个博客是不是要动态资源，还是直接用前端的技术来做检索，并且还将资源直接以静态的方式存储在服务器上。然后备份一份（所谓的持久化到 mysql），给后端做处理，在后台管理页面也能展示不一样的东西。因为如果这样做的话，有几个优势吧：<br>\n其一，消耗的资源小，并且静态的博客也可以完全用之前的一套，少消耗点精力，再者我不用另外租服务器了<br>\n其二，这本来就没打算给外界访问，所以后台做线下处理很符合我的需求，但是就是需要手动同步数据，就很无语，不知道有什么什么其他的好方法。</p>\n<p>但是思来想去，还是觉得前后端分离要高大上一点，也就是有违博客的初衷了。</p>\n<h3 id=\"小麻烦\"><a class=\"markdownIt-Anchor\" href=\"#小麻烦\">#</a> 小麻烦</h3>\n<p>唉，直接叹气，md<br>\n 简直对前端一窍不通，主要是感觉之前学的 vue，以及一些基础的 html，css，js。到如今这个封装的不像样的年代，总感觉中间搁着好多层，就好比后端，springboot 和原生的 java 也搁着好多层，但是熟悉的就用着很顺手，不过是个注解 + 配置的事。但是对于不熟悉前端的我而言，这个就跟看天书一样，很是无力，我想，自定义有点远去了。</p>\n<p>我现在要干的事，是将这个获取静态资源的方式，直接以 api 的方式来调取后端接口，这个基于 vue 写 axios 我倒是没问题，后端 springboot 我也没问题，就是不知道如何分离这段前端的代码。按理说，这个前端的代码里面，肯定有获取 source 文件里面资源，然后调用 markdown 解析器，结合主题，将文档转化为 html 的一个过程。找到这个，将这个资源的获取，直接替换成 api，说起来很简单，但是我还没看代码，还不确定是不是这么简单。</p>\n<p>目前还不知道这个站内搜索的功能是不是直接 nodejs 做的，如果我不前后端分离的话，那就很简单，配置一下，也就是需要去找找文档，配置一下这块的东西，但我如果要分离的话…，同上</p>\n<p>最大的叹息就是他娘的，这个自定义主题的事了，我看到了我很喜欢的主题，但是人不开源，我也想自力更生一波，但是以前写前端都是小孩子过家家，搁大人面前玩泥巴，幼稚的很呐。那界面也是离谱的狠，哪有专门搞前端的厉害。</p>\n<p>吐槽归吐槽，还是该做啥做啥，目前就配置着用呗。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/",
            "url": "http://example.com/2023/07/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/",
            "title": "我的第一篇blog",
            "date_published": "2023-07-13T06:14:28.000Z",
            "content_html": "<blockquote><p>优雅的人，都要搞自己的博客。</p>\n<footer><strong>——鲁迅</strong></footer></blockquote>\n<p>当我接触到代码的小世界的时候，我就立志要写出优雅的代码。正当我为了这个宏伟的目标而努力的时候，偶然间我看见了鲁大师的名言，所以我来了！</p>\n<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>不知道大家是怎么想的，我打算搞个自己的博客的第一出发点就是，能够有个完全由自己 DIY 的小世界。<br>\n这个小世界，就好比小时候的秘密基地，只有你有这个地方的钥匙，可以天马行空，可以记录任何自己想记录的东西，是不是很激动，反正我内心激动无比。<br>\n这个小世界，就好比一扇单向可见的玻璃，当你建立域名，将这个小世界挂出去的时候，就感觉所有人都看到了，但是你的网址并没有被搜索引擎收录，当然可以配置，但是这种感觉就是相当的奇妙。<br>\n这个小世界，此处并没有排比，哈哈！<br>\nPS：我是真的想写好第一篇 blog 的前言，但是我一码字，就跟个手残党一样，脑子里骚操作一堆，实操只会平 A，skr…，麻了欸。</p>\n<h3 id=\"我是谁\"><a class=\"markdownIt-Anchor\" href=\"#我是谁\">#</a> 我是谁</h3>\n<p>哈哈哈，没错，我是这里的站长！！！<br>\n我命由我不由…，咳咳，</p>\n<h3 id=\"它是谁\"><a class=\"markdownIt-Anchor\" href=\"#它是谁\">#</a> 它是谁</h3>\n<p>这个有说法的，这个地方我想让它继承我毕生所学，将来世袭给…。总而言之，我想叫它多面体，为什么不叫冰柠檬…</p>\n<h3 id=\"我想干什么\"><a class=\"markdownIt-Anchor\" href=\"#我想干什么\">#</a> 我想干什么</h3>\n<p>这个也有说法的，直接整的专业点的好了。<br>\n作为一个站长，我有建设，维护和使用它的权力和义务。<br>\n所以<br>\n 1、我会在这里发文章，可以是技术文，口水文。目前来讲我是有很多想法的，我想写一些技术博客，却不放在 CSDN，知乎、掘金这些平台上面；我想发一些日常，但是却不发在朋友圈、空间、微博这些社交平台上面；我想记录一些金句，包括抽象的、富含文艺气息的以及其他；我想罗列一些自己的计划，可以是长期的 flag，也可以是短期的待办；我想…<br>\n2、我会改造多面体，真的，当你搞个自己的博客，你就感觉这就像你的孩子，你喜欢的人一样，想起它你就会情不自禁的嘴角上扬。目前这个博客只是静态的 page，用 Hexo 搭建的，使用的是 shokaX 主题，搞了个阿里的域名，静态资源挂在了 github 上面。我目前有很多很多的想法，但是鉴于个人能力，想法只能是想法，但是我已经迈出了最为艰难的一步，后面会写一篇关于我的建设的文章。<br>\n3、我会维护多面体，这也有很多的方面吧，运营方面的话，就是这个域名啊，后面我加的东西多了，我可能就得办个服务器，不能再用 github 来托管了；对于站点本身，也就是架构，如果时间够久，肯定会面临着技术架构翻新的时候，所以我也会尽量保证紧跟时代的潮流。我当然想自己搞个主题，100% 量身打造，可是现实很骨感，我就尽量挑选比较贴合自己阶段审美的主题，添加一些自己需要的功能、专栏；对于整个开发的流程，目前比较简陋，开发部署，搞个文章都很轻松，但是后面加入后台的前后端，并且数据量，整个平台的复杂度上来的话，我感觉需要使用 CI/CD 工具，并且加入数据分析等等东西，<br>\n总之，感觉目前就是处于头脑风暴阶段，什么都想干，什么都干不了，所以经验告诉我，我需要细化，我需要一步步慢慢来，我目前想到的最好的办法就是：<br>\n我面临的敌人前所未有的强大，我想建设好多面体，我就需要让我自己保持新鲜的活力，让自己承受刚刚好的压力，并且一直能够进步，我相信，这样的话我应该能走的远一些。<br>\n譬如，我另一个想法，我不打算搞这个博客站点的数据，打算随便搞点 md 进来，丰富一下数据，然后直接搞后端，搞一些数据分析，清洗数据，没准结合一下大语言模型等等，但是想着想着就不想搞了。<br>\n思来想去，我总觉得，要想长久经营下去，得要建立数据感情，也就是，这个站点的数据都是自己的，也就是这些文章都是我想发的，想写的，这样我才会想着更好的去建设多面体。<br>\n所以，我目前就打算多写一些文章，罗列一些技术栈，画一些设计文档等等</p>\n",
            "tags": [
                "hello blog"
            ]
        }
    ]
}