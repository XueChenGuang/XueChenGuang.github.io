{
    "version": "https://jsonfeed.org/version/1",
    "title": "该死的秋招 • All posts by \"thread\" tag",
    "description": "孵化中···",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/10/06/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E3%80%81bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81thread%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/",
            "url": "http://example.com/2023/10/06/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E3%80%81bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81thread%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/",
            "title": "类加载机制、bean生命周期、thread生命周期",
            "date_published": "2023-10-06T09:45:00.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>原先是只打算写生命周期的，但是看到 bean 的生命周期的时候就联想到了类加载机制，其也有一套跟 bean 很像的生命周期</p>\n<h3 id=\"类加载机制\"><a class=\"markdownIt-Anchor\" href=\"#类加载机制\">#</a> 类加载机制</h3>\n<p>直接上图<br>\n<img data-src=\"https://pic.imgdb.cn/item/6521506bc458853aef6c916d.jpg\" alt=\"\"></p>\n<p>加载也就是加载 class 文件，然后将 class 文件解析成 java 类存放在内存中，包括方法区和栈</p>\n<p>这边说一下方法区，方法区是抽象的概念，1.8 之前的实现是永久代，后面转为原空间了；对于常量池、静态变量等之前存在方法区中，现在存放在堆中</p>\n<p>具体说一下连接阶段干的事：</p>\n<ul>\n<li>验证：加载之后验证一些错误，文件类型，元数据，字节码等等</li>\n<li>准备：主要是给静态变量赋零值</li>\n<li>解析：将符号引用转为直接引用，主要分为静态解析和动态解析，使用 string 来标记引用的类，如果是静态解析，那么在运行时就直接使用地址进行替换 s；如果涉及到多态的话，就是动态解析了，那么会在具体调用的时候才进行 s 的替换</li>\n</ul>\n<p>对于初始化，就是对静态资源和成员变量进行赋值，并不涉及到构造函数</p>\n<p>玛德感觉不是很懂，很牵强，后面再说</p>\n<h3 id=\"类加载器\"><a class=\"markdownIt-Anchor\" href=\"#类加载器\">#</a> 类加载器</h3>\n<p><img data-src=\"https://pic.imgdb.cn/item/652164e8c458853aef77e771.jpg\" alt=\"\"><br>\n类加载器负责的就是将 class 文件装进虚拟机，主要有三类加载器<br>\n bootstrap、ext、以及 system（application） classloader</p>\n<p>说一下这三个负责加载的类：</p>\n<ul>\n<li>bootstrap 负责加载 jre/jre-bin 下面的核心类</li>\n<li>ext 负责加载 jre-bin-ext 下面的扩展类</li>\n<li>system 或者说 app 负责加载我们写的 java 类</li>\n</ul>\n<p>这里说一下如何判断两个类不一样<br>\n首先，全限定名称不同；其次，要被不同的类加载器加载。因为每个类加载器都有自己的命名空间，所以不同加载了那么就是不同，即使全名相同。</p>\n<p>所以出现了双亲委派机制，具体的实现也就是 loadClass 这个方法实现的，如果我们自定义类加载器，也就是继承 classLoader 后，重写 loadClass 方法，那么就会破坏双亲委派机制，可以直接指定我们的自定义 loader 去加载指定的类，但是对于 java 核心的类库是不行的，会报错（网上这么说的，具体没试过，sun 公司对于 JVM 的保护吧）</p>\n<p>正常的 loadClass 有几个步骤：</p>\n<ul>\n<li>查缓存，看看有没有；有的话直接加载</li>\n<li>没有，那么交给上层，也就是双亲去加载，直到最高层也就是 bootstrap</li>\n<li>最后调用 findClass 来加载</li>\n</ul>\n<h4 id=\"破坏双亲委派机制\"><a class=\"markdownIt-Anchor\" href=\"#破坏双亲委派机制\">#</a> 破坏双亲委派机制</h4>\n<p>常见的破坏双亲委派机制的场景，常见的有两个：</p>\n<ul>\n<li>热部署，也就是通过直接加载最新的类，完成热部署，但是这个类名是完全相同的，所以要完成类的加载，那么就需要使用不同的类加载器，所以破坏了唯一加载的原则</li>\n<li>SPI 的实现如 JDBC，也就是核心类需要依靠外部类的情况，典型的就是数据库的加载，不同的厂商依据同一套规则给出不同的实现，那么类加载的时候，到上层 bootstrap 只能加载核心的类，但是核心类依赖外部类的实现（也就是 classpath 下的类），那么这个时候就直接调用线程上下文类加载器完成类的加载。  PS：这边讲一下为什么用线程上下文而不是用 system 直接指定，因为不同的部署环境，他们的类加载器不同，比如 web 等，用的不一定是 system，那么使用线程动态获取，是最合适的。</li>\n</ul>\n<p>这篇讲的很好<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmF6ZWppYW4vYXJ0aWNsZS9kZXRhaWxzLzczNDEzMjky\"> https://blog.csdn.net/javazejian/article/details/73413292</span></p>\n<h3 id=\"bean的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#bean的生命周期\">#</a> Bean 的生命周期</h3>\n<p>对于 bean 的生命周期大致就可以说三个，</p>\n<ul>\n<li>实例化</li>\n<li>填充属性</li>\n<li>初始化</li>\n</ul>\n<p>主要的流程感觉就是加载 xml 或者是注解，然后调用 beanDefinition 反射创建 bean，属性填充，初始化，使用，销毁等等一系列的</p>\n<p>其中涉及到 bean 如果继承了某些类的话，就可以使用钩子来在固定的节点加入一些自定义的处理。例如 aware 就是在属性填充之后，还可以继承 BeanPostProcessor 来在初始化前后进行一些处理</p>\n<p>感觉也就这么多，这边就会涉及到循环依赖吧，按照网上的说法，bean 的实例化包含了 JVM 的一系列过程，感觉是这么回事，，，。</p>\n<h3 id=\"thread的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#thread的生命周期\">#</a> Thread 的生命周期</h3>\n",
            "tags": [
                "Spring",
                "Thread"
            ]
        }
    ]
}