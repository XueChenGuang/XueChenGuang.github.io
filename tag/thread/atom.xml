<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>该死的秋招 • Posts by &#34;thread&#34; tag</title>
    <link href="http://example.com" />
    <updated>2023-10-06T09:45:00.000Z</updated>
    <category term="hello blog" />
    <category term="设计模式" />
    <category term="MySQL" />
    <category term="算法" />
    <category term="Redis" />
    <category term="其他" />
    <category term="分布式" />
    <category term="数据结构" />
    <category term="Spring" />
    <category term="Thread" />
    <category term="Java" />
    <category term="JDK" />
    <category term="SQL" />
    <category term="JVM" />
    <category term="多线程" />
    <entry>
        <id>http://example.com/2023/10/06/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E3%80%81bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81thread%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
        <title>类加载机制、bean生命周期、thread生命周期</title>
        <link rel="alternate" href="http://example.com/2023/10/06/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E3%80%81bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81thread%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
        <content type="html">&lt;h3 id=&#34;写在前面&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#写在前面&#34;&gt;#&lt;/a&gt; 写在前面&lt;/h3&gt;
&lt;p&gt;原先是只打算写生命周期的，但是看到 bean 的生命周期的时候就联想到了类加载机制，其也有一套跟 bean 很像的生命周期&lt;/p&gt;
&lt;h3 id=&#34;类加载机制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#类加载机制&#34;&gt;#&lt;/a&gt; 类加载机制&lt;/h3&gt;
&lt;p&gt;直接上图&lt;br&gt;
&lt;img data-src=&#34;https://pic.imgdb.cn/item/6521506bc458853aef6c916d.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;加载也就是加载 class 文件，然后将 class 文件解析成 java 类存放在内存中，包括方法区和栈&lt;/p&gt;
&lt;p&gt;这边说一下方法区，方法区是抽象的概念，1.8 之前的实现是永久代，后面转为原空间了；对于常量池、静态变量等之前存在方法区中，现在存放在堆中&lt;/p&gt;
&lt;p&gt;具体说一下连接阶段干的事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;验证：加载之后验证一些错误，文件类型，元数据，字节码等等&lt;/li&gt;
&lt;li&gt;准备：主要是给静态变量赋零值&lt;/li&gt;
&lt;li&gt;解析：将符号引用转为直接引用，主要分为静态解析和动态解析，使用 string 来标记引用的类，如果是静态解析，那么在运行时就直接使用地址进行替换 s；如果涉及到多态的话，就是动态解析了，那么会在具体调用的时候才进行 s 的替换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于初始化，就是对静态资源和成员变量进行赋值，并不涉及到构造函数&lt;/p&gt;
&lt;p&gt;玛德感觉不是很懂，很牵强，后面再说&lt;/p&gt;
&lt;h3 id=&#34;类加载器&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#类加载器&#34;&gt;#&lt;/a&gt; 类加载器&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://pic.imgdb.cn/item/652164e8c458853aef77e771.jpg&#34; alt=&#34;&#34;&gt;&lt;br&gt;
类加载器负责的就是将 class 文件装进虚拟机，主要有三类加载器&lt;br&gt;
 bootstrap、ext、以及 system（application） classloader&lt;/p&gt;
&lt;p&gt;说一下这三个负责加载的类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bootstrap 负责加载 jre/jre-bin 下面的核心类&lt;/li&gt;
&lt;li&gt;ext 负责加载 jre-bin-ext 下面的扩展类&lt;/li&gt;
&lt;li&gt;system 或者说 app 负责加载我们写的 java 类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里说一下如何判断两个类不一样&lt;br&gt;
首先，全限定名称不同；其次，要被不同的类加载器加载。因为每个类加载器都有自己的命名空间，所以不同加载了那么就是不同，即使全名相同。&lt;/p&gt;
&lt;p&gt;所以出现了双亲委派机制，具体的实现也就是 loadClass 这个方法实现的，如果我们自定义类加载器，也就是继承 classLoader 后，重写 loadClass 方法，那么就会破坏双亲委派机制，可以直接指定我们的自定义 loader 去加载指定的类，但是对于 java 核心的类库是不行的，会报错（网上这么说的，具体没试过，sun 公司对于 JVM 的保护吧）&lt;/p&gt;
&lt;p&gt;正常的 loadClass 有几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查缓存，看看有没有；有的话直接加载&lt;/li&gt;
&lt;li&gt;没有，那么交给上层，也就是双亲去加载，直到最高层也就是 bootstrap&lt;/li&gt;
&lt;li&gt;最后调用 findClass 来加载&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;破坏双亲委派机制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#破坏双亲委派机制&#34;&gt;#&lt;/a&gt; 破坏双亲委派机制&lt;/h4&gt;
&lt;p&gt;常见的破坏双亲委派机制的场景，常见的有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;热部署，也就是通过直接加载最新的类，完成热部署，但是这个类名是完全相同的，所以要完成类的加载，那么就需要使用不同的类加载器，所以破坏了唯一加载的原则&lt;/li&gt;
&lt;li&gt;SPI 的实现如 JDBC，也就是核心类需要依靠外部类的情况，典型的就是数据库的加载，不同的厂商依据同一套规则给出不同的实现，那么类加载的时候，到上层 bootstrap 只能加载核心的类，但是核心类依赖外部类的实现（也就是 classpath 下的类），那么这个时候就直接调用线程上下文类加载器完成类的加载。  PS：这边讲一下为什么用线程上下文而不是用 system 直接指定，因为不同的部署环境，他们的类加载器不同，比如 web 等，用的不一定是 system，那么使用线程动态获取，是最合适的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇讲的很好&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmF6ZWppYW4vYXJ0aWNsZS9kZXRhaWxzLzczNDEzMjky&#34;&gt; https://blog.csdn.net/javazejian/article/details/73413292&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;bean的生命周期&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#bean的生命周期&#34;&gt;#&lt;/a&gt; Bean 的生命周期&lt;/h3&gt;
&lt;p&gt;对于 bean 的生命周期大致就可以说三个，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实例化&lt;/li&gt;
&lt;li&gt;填充属性&lt;/li&gt;
&lt;li&gt;初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要的流程感觉就是加载 xml 或者是注解，然后调用 beanDefinition 反射创建 bean，属性填充，初始化，使用，销毁等等一系列的&lt;/p&gt;
&lt;p&gt;其中涉及到 bean 如果继承了某些类的话，就可以使用钩子来在固定的节点加入一些自定义的处理。例如 aware 就是在属性填充之后，还可以继承 BeanPostProcessor 来在初始化前后进行一些处理&lt;/p&gt;
&lt;p&gt;感觉也就这么多，这边就会涉及到循环依赖吧，按照网上的说法，bean 的实例化包含了 JVM 的一系列过程，感觉是这么回事，，，。&lt;/p&gt;
&lt;h3 id=&#34;thread的生命周期&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#thread的生命周期&#34;&gt;#&lt;/a&gt; Thread 的生命周期&lt;/h3&gt;
</content>
        <category term="Spring" />
        <category term="Thread" />
        <updated>2023-10-06T09:45:00.000Z</updated>
    </entry>
</feed>
