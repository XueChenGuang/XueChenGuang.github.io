{
    "version": "https://jsonfeed.org/version/1",
    "title": "该死的秋招 • All posts by \"多线程\" tag",
    "description": "孵化中···",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/10/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/",
            "url": "http://example.com/2023/10/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/",
            "title": "多线程的三大特性",
            "date_published": "2023-10-11T03:49:38.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>深信服面试的时候，面到了多线程的三大特性，虽然多线程这块比较熟悉，但是概念没有对应上，在面试官友好的提示下说了出来，但回想一下确实是自己还没有完全搞明白，不然怎么会对应不上这个简单的概念呢，话不多说，直接开始</p>\n<h3 id=\"多线程的三大特性\"><a class=\"markdownIt-Anchor\" href=\"#多线程的三大特性\">#</a> 多线程的三大特性</h3>\n<p>并不是说起个多线程就一定满足三大特性，只是不满足三大特性会有很多的线程安全问题，那么要消除线程安全，就需要选择性的满足这三大特性，所以其中的点还是蛮灵活的。</p>\n<p>网上都是按照可见性，原子性，顺序性来讲；但是其实这三点并不能完全分隔，只能说概念上可以分割一下</p>\n<p>我起初了解并意识到三大特性的时间还是在了解内存模型的时候，从硬件到 JVM 的内存模型，有个映射关系，具体直接看图<br>\n<img data-src=\"https://pic.imgdb.cn/item/65261d4dc458853aef2d8210.jpg\" alt=\"\"></p>\n<p>这边也有一个可以说的点，我就说的长一点好了：<br>\nCPU 的处理速度和内存的读写速度差距过大，所以在 CPU 和内存之间加入了 CPU 寄存器和 CPU 缓存来提高效率，也就是 SRAM 和 DRAM 的来源了。</p>\n<p>这样的结构对于单线程来说，也就是单核 CPU 来说是完全没问题的。但是多核的发展，给这样的模型带来了困扰，也就是经典的缓存不一致问题，也就是可以想象为数据共享，但是主存中才是真正的共享数据，缓存中是数据副本，所以造成了不一致，因而后面出现了缓存一致性协议，直白点说就是涉及到了同步问题。因而就会出现对于耗时长的指令会到之后面的指令暂停，所以就出现了指令重排序。所谓的指令重拍，并不是乱排，而是让不相干的指令可以不用等待而提前执行。</p>\n<p><img data-src=\"https://pic.imgdb.cn/item/65261f17c458853aef33887e.jpg\" alt=\"\"><br>\n这个是线程的执行逻辑，其中与主存打交道交给 JMM 控制，那么具体的映射关系是 thread 中用到的 threadstack 大多存放在缓存中，但是对于 heap 大多存放在主存中，所以对于下层的屏蔽，我们只需要和 threadstack 以及 heap 打交道，而不必与硬件打交道。线程中也是用到了工作内存和主存，感觉和 CPU 缓存以及主存差不多。</p>\n<p>有了上面的内存结构，那么就出现了下面的线程三大特性了：</p>\n<ul>\n<li>可见性，由于内存模型的问题，大致可以分为主存和工作内存，所以多线程工作的时候，对于工作内存中的变量（主存副本），存在不一致的情况。要保证可见那么可以通过 volatile 标记或者 synchronized 关键字或者 lock 来实现。简单说一下加锁和 volatile 的区别，volatile 强制更改后刷新到主存，并且读取 volatile 变量的时候强制从主存中读取。对于加锁而言，修改之后提交到主存，读取的时候需要删除工作内存中的数据，然后从主存中进行读取（其中涉及到了内存 lock 和 unlock 指令）</li>\n<li>原子性，一组要么成功要么失败</li>\n<li>顺序性，主要是要讲一下 happends before 原则。涉及三点主要，实际上跟多，单线程中的总式顺序的，也就是无论指令如何重排，结果肯定与顺序读取的代码是一致的结果；加锁，同一个锁的加锁肯定在解锁之前；volatile 前面的肯定先于后面的</li>\n</ul>\n",
            "tags": [
                "多线程"
            ]
        }
    ]
}