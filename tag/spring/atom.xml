<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>该死的秋招 • Posts by &#34;spring&#34; tag</title>
    <link href="http://example.com" />
    <updated>2023-10-07T03:59:35.000Z</updated>
    <category term="hello blog" />
    <category term="设计模式" />
    <category term="MySQL" />
    <category term="算法" />
    <category term="Redis" />
    <category term="其他" />
    <category term="分布式" />
    <category term="数据结构" />
    <category term="Spring" />
    <category term="Thread" />
    <category term="Java" />
    <entry>
        <id>http://example.com/2023/10/07/IOC%E5%92%8CAOP/</id>
        <title>IOC和AOP</title>
        <link rel="alternate" href="http://example.com/2023/10/07/IOC%E5%92%8CAOP/"/>
        <content type="html">&lt;h3 id=&#34;写在前面&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#写在前面&#34;&gt;#&lt;/a&gt; 写在前面&lt;/h3&gt;
&lt;p&gt;以前也学过，也系统的记录过，但是一个是角度不一样，一个是忘记了。现在就从使用 + 原理，重新记录一下两个核心思想&lt;/p&gt;
&lt;h3 id=&#34;ioc&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ioc&#34;&gt;#&lt;/a&gt; IOC&lt;/h3&gt;
&lt;p&gt;控制反转，是一个思想，具体的实现是 DI 依赖注入。&lt;br&gt;
对于 IOC 思想，几乎处处可见，对于 servlet、监听器、过滤器这些也是 tomcat 通过控制反转创建的，所以 IOC 并不是 spring 特有的&lt;/p&gt;
&lt;p&gt;依赖注入 DI，笼统的来说就是之前通过 new 的现在交给一个叫做 context 的东西来创建，也就是交给了第三方而不是程序员来控制资源的创建。&lt;/p&gt;
&lt;h4 id=&#34;注入是怎么注入的&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注入是怎么注入的&#34;&gt;#&lt;/a&gt; 注入，是怎么注入的&lt;/h4&gt;
&lt;p&gt;主要分为 set 注入和构造函数注入，有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;xml 文件，主要通过 property 标签和 constructor 标签完成注入，可以添加 autowire 属性，来完成 byname 还是 bytype 注入&lt;/li&gt;
&lt;li&gt;注解，支持注入的注解有 @component、@service、@controller、@repository、@bean、@component 等声明 bean，也就是放到 context 中，使用 @resource、@autowire、@value 等完成注入&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;实现原理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#实现原理&#34;&gt;#&lt;/a&gt; 实现原理&lt;/h4&gt;
&lt;p&gt;简单来说就是 map + 反射，用 map 存储唯一 id 以及对应的 bean，通过 id 定位，并通过反射来获取 bean 信息，完成注入&lt;/p&gt;
&lt;h4 id=&#34;循环依赖&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#循环依赖&#34;&gt;#&lt;/a&gt; 循环依赖&lt;/h4&gt;
&lt;p&gt;这边也就是引入三级缓存解决循环依赖的问题，循环依赖最简单的场景就是 a-b，b-a 有点像死锁的现象，导致出 bug。&lt;/p&gt;
&lt;p&gt;spring 对象产生需要三步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;creatBeanInstance 实例化，也就是调用构造函数&lt;/li&gt;
&lt;li&gt;populateBean 填充属性&lt;/li&gt;
&lt;li&gt;initializeBean 初始化，调用 xml 文件（也就是赋值吧）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;45&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt; * 实际创建指定的bean。 此时，预创建处理已经发生，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt; * 例如 检查&amp;#123;&lt;span class=&#34;doctag&#34;&gt;@code&lt;/span&gt; postProcessBeforeInstantiation&amp;#125;回调。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt; * 区分默认bean实例化、使用工厂方法和自动装配构造函数。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;protected&lt;/span&gt; Object &lt;span class=&#34;title function_&#34;&gt;doCreateBean&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;final&lt;/span&gt; String beanName, &lt;span class=&#34;keyword&#34;&gt;final&lt;/span&gt; RootBeanDefinition mbd, &lt;span class=&#34;keyword&#34;&gt;final&lt;/span&gt; Object[] args)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// Instantiate the bean.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;BeanWrapper&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;instanceWrapper&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .....&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (instanceWrapper == &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        instanceWrapper = createBeanInstance(beanName, mbd, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .....&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// Eagerly cache singletons to be able to resolve circular references&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// even when triggered by lifecycle interfaces like BeanFactoryAware.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;earlySingletonExposure&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; (mbd.isSingleton() &amp;amp;&amp;amp; &lt;span class=&#34;built_in&#34;&gt;this&lt;/span&gt;.allowCircularReferences &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            isSingletonCurrentlyInCreation(beanName));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (earlySingletonExposure) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (logger.isDebugEnabled()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            logger.debug(&lt;span class=&#34;string&#34;&gt;&amp;quot;Eagerly caching bean &amp;#x27;&amp;quot;&lt;/span&gt; + beanName +&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    &lt;span class=&#34;string&#34;&gt;&amp;quot;&amp;#x27; to allow for resolving potential circular references&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;//添加到三级缓存中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        addSingletonFactory(beanName, &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ObjectFactory&lt;/span&gt;&amp;lt;Object&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;meta&#34;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; Object &lt;span class=&#34;title function_&#34;&gt;getObject&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;throws&lt;/span&gt; BeansException &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; getEarlyBeanReference(beanName, mbd, bean);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// Initialize the bean instance.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;exposedObject&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; bean;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;//填充依赖的bean实例。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        populateBean(beanName, mbd, instanceWrapper);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (exposedObject != &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;comment&#34;&gt;//调用spring xml中的init 方法。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            exposedObject = initializeBean(beanName, exposedObject, mbd);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    ......&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; exposedObject;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;所以循环依赖主要出现在 1，2 阶段。场景如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造函数中调用其他的 bean，形成 a-b-a 循环依赖&lt;/li&gt;
&lt;li&gt;填充属性的时候调用其他的 bean，形成 a-b-a 循环依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于循环依赖，spring 引入三级缓存来解决，意思就是执行步骤 1 的时候，将半成品 a 类，放入到三级缓存中，这样如果 a 需要 b，那么就会从三级缓存中以此寻找，1 级（singletonObject）、2 级（earlySingletonObject）、3 级（sigletonFactory）。这样找下来，可以看到，在上述的代码中，步骤一，也就是实例化后，会将这个半成品暴露到三级缓存中，那么 a 去找 b 的时候找不到，但是三级缓存中有 b；反过来，b 去找 a 的时候就找到了，从而解决循环依赖。&lt;/p&gt;
&lt;p&gt;这里有一点就是如果在三级缓存中招到了，并且完成了一个级别之后，对应的缓存中就要删除，上升一个级别。&lt;/p&gt;
&lt;h3 id=&#34;无法解决的循环依赖&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#无法解决的循环依赖&#34;&gt;#&lt;/a&gt; 无法解决的循环依赖&lt;/h3&gt;
&lt;p&gt;对于无法解决的循环依赖问题，有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;prototype 类型的 bean，因为他们不加入缓存，所以三级缓存策略没有用&lt;/li&gt;
&lt;li&gt;构造函数中的循环依赖，因为三级缓存生效是在实例化之后，所以如果第一步就存在循环依赖，那么是无法解决的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于以上两个场景，都是用延迟加载即可，@lazy 注解，具体的原理目前不是很清楚&lt;/p&gt;
</content>
        <category term="Spring" />
        <updated>2023-10-07T03:59:35.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/10/06/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
        <title>生命周期</title>
        <link rel="alternate" href="http://example.com/2023/10/06/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
        <content type="html">&lt;h3 id=&#34;写在前面&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#写在前面&#34;&gt;#&lt;/a&gt; 写在前面&lt;/h3&gt;
&lt;p&gt;这篇主要写明白会问到的生命周期，对于 Java 中常用到的，也就线程和 Bean 了，那么这两个的声明周期是什么呢，经常有这个疑问，但是没有很明确的记得，这就会在面试的时候卡壳。&lt;/p&gt;
&lt;h3 id=&#34;bean的生命周期&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#bean的生命周期&#34;&gt;#&lt;/a&gt; Bean 的生命周期&lt;/h3&gt;
&lt;h3 id=&#34;thread的生命周期&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#thread的生命周期&#34;&gt;#&lt;/a&gt; Thread 的生命周期&lt;/h3&gt;
</content>
        <category term="Spring" />
        <category term="Thread" />
        <updated>2023-10-06T09:45:00.000Z</updated>
    </entry>
</feed>
