<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>该死的秋招 • Posts by &#34;spring&#34; tag</title>
    <link href="http://example.com" />
    <updated>2023-10-07T03:59:35.000Z</updated>
    <category term="hello blog" />
    <category term="设计模式" />
    <category term="MySQL" />
    <category term="算法" />
    <category term="Redis" />
    <category term="其他" />
    <category term="分布式" />
    <category term="数据结构" />
    <category term="Spring" />
    <category term="Thread" />
    <category term="Java" />
    <entry>
        <id>http://example.com/2023/10/07/IOC%E5%92%8CAOP/</id>
        <title>IOC和AOP</title>
        <link rel="alternate" href="http://example.com/2023/10/07/IOC%E5%92%8CAOP/"/>
        <content type="html">&lt;h3 id=&#34;写在前面&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#写在前面&#34;&gt;#&lt;/a&gt; 写在前面&lt;/h3&gt;
&lt;p&gt;以前也学过，也系统的记录过，但是一个是角度不一样，一个是忘记了。现在就从使用 + 原理，重新记录一下两个核心思想&lt;/p&gt;
&lt;h3 id=&#34;ioc&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ioc&#34;&gt;#&lt;/a&gt; IOC&lt;/h3&gt;
&lt;p&gt;控制反转，是一个思想，具体的实现是 DI 依赖注入。&lt;br&gt;
对于 IOC 思想，几乎处处可见，对于 servlet、监听器、过滤器这些也是 tomcat 通过控制反转创建的，所以 IOC 并不是 spring 特有的&lt;/p&gt;
&lt;p&gt;依赖注入 DI，笼统的来说就是之前通过 new 的现在交给一个叫做 context 的东西来创建，也就是交给了第三方而不是程序员来控制资源的创建。&lt;/p&gt;
&lt;h4 id=&#34;注入是怎么注入的&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#注入是怎么注入的&#34;&gt;#&lt;/a&gt; 注入，是怎么注入的&lt;/h4&gt;
&lt;p&gt;主要分为 set 注入和构造函数注入，有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;xml 文件，主要通过 property 标签和 constructor 标签完成注入，可以添加 autowire 属性，来完成 byname 还是 bytype 注入&lt;/li&gt;
&lt;li&gt;注解，支持注入的注解有 @component、@service、@controller、@repository、@bean、@component 等声明 bean，也就是放到 context 中，使用 @resource、@autowire、@value 等完成注入&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;实现原理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#实现原理&#34;&gt;#&lt;/a&gt; 实现原理&lt;/h4&gt;
&lt;p&gt;简单来说就是 map + 反射，用 map 存储唯一 id 以及对应的 bean，通过 id 定位，并通过反射来获取 bean 信息，完成注入&lt;/p&gt;
&lt;h4 id=&#34;循环依赖&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#循环依赖&#34;&gt;#&lt;/a&gt; 循环依赖&lt;/h4&gt;
&lt;p&gt;这边也就是引入三级缓存解决循环依赖的问题，循环依赖最简单的场景就是 a-b，b-a 有点像死锁的现象，导致出 bug。&lt;/p&gt;
&lt;p&gt;spring 对象产生需要三步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;creatBeanInstance 实例化，也就是调用构造函数&lt;/li&gt;
&lt;li&gt;populateBean 填充属性&lt;/li&gt;
&lt;li&gt;initializeBean 初始化，调用 xml 文件（也就是赋值吧）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;45&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt; * 实际创建指定的bean。 此时，预创建处理已经发生，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt; * 例如 检查&amp;#123;&lt;span class=&#34;doctag&#34;&gt;@code&lt;/span&gt; postProcessBeforeInstantiation&amp;#125;回调。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt; * 区分默认bean实例化、使用工厂方法和自动装配构造函数。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;protected&lt;/span&gt; Object &lt;span class=&#34;title function_&#34;&gt;doCreateBean&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;final&lt;/span&gt; String beanName, &lt;span class=&#34;keyword&#34;&gt;final&lt;/span&gt; RootBeanDefinition mbd, &lt;span class=&#34;keyword&#34;&gt;final&lt;/span&gt; Object[] args)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// Instantiate the bean.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;BeanWrapper&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;instanceWrapper&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .....&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (instanceWrapper == &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        instanceWrapper = createBeanInstance(beanName, mbd, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    .....&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// Eagerly cache singletons to be able to resolve circular references&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// even when triggered by lifecycle interfaces like BeanFactoryAware.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;earlySingletonExposure&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; (mbd.isSingleton() &amp;amp;&amp;amp; &lt;span class=&#34;built_in&#34;&gt;this&lt;/span&gt;.allowCircularReferences &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            isSingletonCurrentlyInCreation(beanName));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (earlySingletonExposure) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (logger.isDebugEnabled()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            logger.debug(&lt;span class=&#34;string&#34;&gt;&amp;quot;Eagerly caching bean &amp;#x27;&amp;quot;&lt;/span&gt; + beanName +&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    &lt;span class=&#34;string&#34;&gt;&amp;quot;&amp;#x27; to allow for resolving potential circular references&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;//添加到三级缓存中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        addSingletonFactory(beanName, &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ObjectFactory&lt;/span&gt;&amp;lt;Object&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;meta&#34;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; Object &lt;span class=&#34;title function_&#34;&gt;getObject&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;throws&lt;/span&gt; BeansException &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; getEarlyBeanReference(beanName, mbd, bean);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// Initialize the bean instance.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;exposedObject&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; bean;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;//填充依赖的bean实例。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        populateBean(beanName, mbd, instanceWrapper);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (exposedObject != &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;comment&#34;&gt;//调用spring xml中的init 方法。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            exposedObject = initializeBean(beanName, exposedObject, mbd);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    ......&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; exposedObject;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;所以循环依赖主要出现在 1，2 阶段。场景如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造函数中调用其他的 bean，形成 a-b-a 循环依赖&lt;/li&gt;
&lt;li&gt;填充属性的时候调用其他的 bean，形成 a-b-a 循环依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于循环依赖，spring 引入三级缓存来解决，意思就是执行步骤 1 的时候，将半成品 a 类，放入到三级缓存中，这样如果 a 需要 b，那么就会从三级缓存中以此寻找，1 级（singletonObject）、2 级（earlySingletonObject）、3 级（sigletonFactory）。这样找下来，可以看到，在上述的代码中，步骤一，也就是实例化后，会将这个半成品暴露到三级缓存中，那么 a 去找 b 的时候找不到，但是三级缓存中有 b；反过来，b 去找 a 的时候就找到了，从而解决循环依赖。&lt;/p&gt;
&lt;p&gt;这里有一点就是如果在三级缓存中招到了，并且完成了一个级别之后，对应的缓存中就要删除，上升一个级别。&lt;/p&gt;
&lt;h3 id=&#34;无法解决的循环依赖&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#无法解决的循环依赖&#34;&gt;#&lt;/a&gt; 无法解决的循环依赖&lt;/h3&gt;
&lt;p&gt;对于无法解决的循环依赖问题，有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;prototype 类型的 bean，因为他们不加入缓存，所以三级缓存策略没有用&lt;/li&gt;
&lt;li&gt;构造函数中的循环依赖，因为三级缓存生效是在实例化之后，所以如果第一步就存在循环依赖，那么是无法解决的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于以上两个场景，都是用延迟加载即可，@lazy 注解，具体的原理目前不是很清楚&lt;/p&gt;
&lt;h3 id=&#34;aop&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#aop&#34;&gt;#&lt;/a&gt; AOP&lt;/h3&gt;
&lt;p&gt;AOP 也就是切面编程，底层原理使用的是动态代理，说到底还是反射机制&lt;/p&gt;
</content>
        <category term="Spring" />
        <updated>2023-10-07T03:59:35.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/10/06/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E3%80%81bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81thread%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
        <title>类加载机制、bean生命周期、thread生命周期</title>
        <link rel="alternate" href="http://example.com/2023/10/06/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E3%80%81bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81thread%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
        <content type="html">&lt;h3 id=&#34;写在前面&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#写在前面&#34;&gt;#&lt;/a&gt; 写在前面&lt;/h3&gt;
&lt;p&gt;原先是只打算写生命周期的，但是看到 bean 的生命周期的时候就联想到了类加载机制，其也有一套跟 bean 很像的生命周期&lt;/p&gt;
&lt;h3 id=&#34;类加载机制&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#类加载机制&#34;&gt;#&lt;/a&gt; 类加载机制&lt;/h3&gt;
&lt;p&gt;直接上图&lt;br&gt;
&lt;img data-src=&#34;https://pic.imgdb.cn/item/6521506bc458853aef6c916d.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;加载也就是加载 class 文件，然后将 class 文件解析成 java 类存放在内存中，包括方法区和栈&lt;/p&gt;
&lt;p&gt;这边说一下方法区，方法区是抽象的概念，1.8 之前的实现是永久代，后面转为原空间了；对于常量池、静态变量等之前存在方法区中，现在存放在堆中&lt;/p&gt;
&lt;p&gt;具体说一下连接阶段干的事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;验证：加载之后验证一些错误，文件类型，元数据，字节码等等&lt;/li&gt;
&lt;li&gt;准备：主要是给静态变量赋零值&lt;/li&gt;
&lt;li&gt;解析：将符号引用转为直接引用，主要分为静态解析和动态解析，使用 string 来标记引用的类，如果是静态解析，那么在运行时就直接使用地址进行替换 s；如果涉及到多态的话，就是动态解析了，那么会在具体调用的时候才进行 s 的替换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于初始化，就是对静态资源和成员变量进行赋值，并不涉及到构造函数&lt;/p&gt;
&lt;p&gt;玛德感觉不是很懂，很牵强，后面再说&lt;/p&gt;
&lt;h3 id=&#34;类加载器&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#类加载器&#34;&gt;#&lt;/a&gt; 类加载器&lt;/h3&gt;
&lt;p&gt;&lt;img data-src=&#34;https://pic.imgdb.cn/item/652164e8c458853aef77e771.jpg&#34; alt=&#34;&#34;&gt;&lt;br&gt;
类加载器负责的就是将 class 文件装进虚拟机，主要有三类加载器&lt;br&gt;
 bootstrap、ext、以及 system（application） classloader&lt;/p&gt;
&lt;p&gt;说一下这三个负责加载的类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bootstrap 负责加载 jre/jre-bin 下面的核心类&lt;/li&gt;
&lt;li&gt;ext 负责加载 jre-bin-ext 下面的扩展类&lt;/li&gt;
&lt;li&gt;system 或者说 app 负责加载我们写的 java 类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里说一下如何判断两个类不一样&lt;br&gt;
首先，全限定名称不同；其次，要被不同的类加载器加载。因为每个类加载器都有自己的命名空间，所以不同加载了那么就是不同，即使全名相同。&lt;/p&gt;
&lt;p&gt;所以出现了双亲委派机制，具体的实现也就是 loadClass 这个方法实现的，如果我们自定义类加载器，也就是继承 classLoader 后，重写 loadClass 方法，那么就会破坏双亲委派机制，可以直接指定我们的自定义 loader 去加载指定的类，但是对于 java 核心的类库是不行的，会报错（网上这么说的，具体没试过，sun 公司对于 JVM 的保护吧）&lt;/p&gt;
&lt;p&gt;正常的 loadClass 有几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查缓存，看看有没有；有的话直接加载&lt;/li&gt;
&lt;li&gt;没有，那么交给上层，也就是双亲去加载，直到最高层也就是 bootstrap&lt;/li&gt;
&lt;li&gt;最后调用 findClass 来加载&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bean的生命周期&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#bean的生命周期&#34;&gt;#&lt;/a&gt; Bean 的生命周期&lt;/h3&gt;
&lt;h3 id=&#34;thread的生命周期&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#thread的生命周期&#34;&gt;#&lt;/a&gt; Thread 的生命周期&lt;/h3&gt;
</content>
        <category term="Spring" />
        <category term="Thread" />
        <updated>2023-10-06T09:45:00.000Z</updated>
    </entry>
</feed>
