{
    "version": "https://jsonfeed.org/version/1",
    "title": "该死的秋招 • All posts by \"spring\" tag",
    "description": "孵化中···",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/10/07/IOC%E5%92%8CAOP/",
            "url": "http://example.com/2023/10/07/IOC%E5%92%8CAOP/",
            "title": "IOC和AOP",
            "date_published": "2023-10-07T03:59:35.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>以前也学过，也系统的记录过，但是一个是角度不一样，一个是忘记了。现在就从使用 + 原理，重新记录一下两个核心思想</p>\n<h3 id=\"ioc\"><a class=\"markdownIt-Anchor\" href=\"#ioc\">#</a> IOC</h3>\n<p>控制反转，是一个思想，具体的实现是 DI 依赖注入。<br>\n对于 IOC 思想，几乎处处可见，对于 servlet、监听器、过滤器这些也是 tomcat 通过控制反转创建的，所以 IOC 并不是 spring 特有的</p>\n<p>依赖注入 DI，笼统的来说就是之前通过 new 的现在交给一个叫做 context 的东西来创建，也就是交给了第三方而不是程序员来控制资源的创建。</p>\n<h4 id=\"注入是怎么注入的\"><a class=\"markdownIt-Anchor\" href=\"#注入是怎么注入的\">#</a> 注入，是怎么注入的</h4>\n<p>主要分为 set 注入和构造函数注入，有两种方式：</p>\n<ul>\n<li>xml 文件，主要通过 property 标签和 constructor 标签完成注入，可以添加 autowire 属性，来完成 byname 还是 bytype 注入</li>\n<li>注解，支持注入的注解有 @component、@service、@controller、@repository、@bean、@component 等声明 bean，也就是放到 context 中，使用 @resource、@autowire、@value 等完成注入</li>\n</ul>\n<h4 id=\"实现原理\"><a class=\"markdownIt-Anchor\" href=\"#实现原理\">#</a> 实现原理</h4>\n<p>简单来说就是 map + 反射，用 map 存储唯一 id 以及对应的 bean，通过 id 定位，并通过反射来获取 bean 信息，完成注入</p>\n<h4 id=\"循环依赖\"><a class=\"markdownIt-Anchor\" href=\"#循环依赖\">#</a> 循环依赖</h4>\n<p>这边也就是引入三级缓存解决循环依赖的问题，循环依赖最简单的场景就是 a-b，b-a 有点像死锁的现象，导致出 bug。</p>\n<p>spring 对象产生需要三步骤：</p>\n<ul>\n<li>creatBeanInstance 实例化，也就是调用构造函数</li>\n<li>populateBean 填充属性</li>\n<li>initializeBean 初始化，调用 xml 文件（也就是赋值吧）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实际创建指定的bean。 此时，预创建处理已经发生，</span></span><br><span class=\"line\"><span class=\"comment\"> * 例如 检查&#123;<span class=\"doctag\">@code</span> postProcessBeforeInstantiation&#125;回调。</span></span><br><span class=\"line\"><span class=\"comment\"> * 区分默认bean实例化、使用工厂方法和自动装配构造函数。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> Object <span class=\"title function_\">doCreateBean</span><span class=\"params\">(<span class=\"keyword\">final</span> String beanName, <span class=\"keyword\">final</span> RootBeanDefinition mbd, <span class=\"keyword\">final</span> Object[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Instantiate the bean.</span></span><br><span class=\"line\">    <span class=\"type\">BeanWrapper</span> <span class=\"variable\">instanceWrapper</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instanceWrapper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">    <span class=\"comment\">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class=\"line\">    <span class=\"comment\">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">earlySingletonExposure</span> <span class=\"operator\">=</span> (mbd.isSingleton() &amp;&amp; <span class=\"built_in\">this</span>.allowCircularReferences &amp;&amp;</span><br><span class=\"line\">            isSingletonCurrentlyInCreation(beanName));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (earlySingletonExposure) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">            logger.debug(<span class=\"string\">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class=\"line\">                    <span class=\"string\">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//添加到三级缓存中</span></span><br><span class=\"line\">        addSingletonFactory(beanName, <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Object <span class=\"title function_\">getObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Initialize the bean instance.</span></span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">exposedObject</span> <span class=\"operator\">=</span> bean;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//填充依赖的bean实例。</span></span><br><span class=\"line\">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (exposedObject != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//调用spring xml中的init 方法。</span></span><br><span class=\"line\">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">return</span> exposedObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以循环依赖主要出现在 1，2 阶段。场景如下：</p>\n<ul>\n<li>构造函数中调用其他的 bean，形成 a-b-a 循环依赖</li>\n<li>填充属性的时候调用其他的 bean，形成 a-b-a 循环依赖</li>\n</ul>\n<p>对于循环依赖，spring 引入三级缓存来解决，意思就是执行步骤 1 的时候，将半成品 a 类，放入到三级缓存中，这样如果 a 需要 b，那么就会从三级缓存中以此寻找，1 级（singletonObject）、2 级（earlySingletonObject）、3 级（sigletonFactory）。这样找下来，可以看到，在上述的代码中，步骤一，也就是实例化后，会将这个半成品暴露到三级缓存中，那么 a 去找 b 的时候找不到，但是三级缓存中有 b；反过来，b 去找 a 的时候就找到了，从而解决循环依赖。</p>\n<p>这里有一点就是如果在三级缓存中招到了，并且完成了一个级别之后，对应的缓存中就要删除，上升一个级别。</p>\n<h3 id=\"无法解决的循环依赖\"><a class=\"markdownIt-Anchor\" href=\"#无法解决的循环依赖\">#</a> 无法解决的循环依赖</h3>\n<p>对于无法解决的循环依赖问题，有两个：</p>\n<ul>\n<li>prototype 类型的 bean，因为他们不加入缓存，所以三级缓存策略没有用</li>\n<li>构造函数中的循环依赖，因为三级缓存生效是在实例化之后，所以如果第一步就存在循环依赖，那么是无法解决的。</li>\n</ul>\n<p>对于以上两个场景，都是用延迟加载即可，@lazy 注解，具体的原理目前不是很清楚</p>\n<h3 id=\"aop\"><a class=\"markdownIt-Anchor\" href=\"#aop\">#</a> AOP</h3>\n<p>AOP 也就是切面编程，底层原理使用的是动态代理，说到底还是反射机制</p>\n",
            "tags": [
                "Spring"
            ]
        },
        {
            "id": "http://example.com/2023/10/06/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E3%80%81bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81thread%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/",
            "url": "http://example.com/2023/10/06/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E3%80%81bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81thread%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/",
            "title": "类加载机制、bean生命周期、thread生命周期",
            "date_published": "2023-10-06T09:45:00.000Z",
            "content_html": "<h3 id=\"写在前面\"><a class=\"markdownIt-Anchor\" href=\"#写在前面\">#</a> 写在前面</h3>\n<p>原先是只打算写生命周期的，但是看到 bean 的生命周期的时候就联想到了类加载机制，其也有一套跟 bean 很像的生命周期</p>\n<h3 id=\"类加载机制\"><a class=\"markdownIt-Anchor\" href=\"#类加载机制\">#</a> 类加载机制</h3>\n<p>直接上图<br>\n<img data-src=\"https://pic.imgdb.cn/item/6521506bc458853aef6c916d.jpg\" alt=\"\"></p>\n<p>加载也就是加载 class 文件，然后将 class 文件解析成 java 类存放在内存中，包括方法区和栈</p>\n<p>这边说一下方法区，方法区是抽象的概念，1.8 之前的实现是永久代，后面转为原空间了；对于常量池、静态变量等之前存在方法区中，现在存放在堆中</p>\n<p>具体说一下连接阶段干的事：</p>\n<ul>\n<li>验证：加载之后验证一些错误，文件类型，元数据，字节码等等</li>\n<li>准备：主要是给静态变量赋零值</li>\n<li>解析：将符号引用转为直接引用，主要分为静态解析和动态解析，使用 string 来标记引用的类，如果是静态解析，那么在运行时就直接使用地址进行替换 s；如果涉及到多态的话，就是动态解析了，那么会在具体调用的时候才进行 s 的替换</li>\n</ul>\n<p>对于初始化，就是对静态资源和成员变量进行赋值，并不涉及到构造函数</p>\n<p>玛德感觉不是很懂，很牵强，后面再说</p>\n<h3 id=\"类加载器\"><a class=\"markdownIt-Anchor\" href=\"#类加载器\">#</a> 类加载器</h3>\n<p><img data-src=\"https://pic.imgdb.cn/item/652164e8c458853aef77e771.jpg\" alt=\"\"><br>\n类加载器负责的就是将 class 文件装进虚拟机，主要有三类加载器<br>\n bootstrap、ext、以及 system（application） classloader</p>\n<p>说一下这三个负责加载的类：</p>\n<ul>\n<li>bootstrap 负责加载 jre/jre-bin 下面的核心类</li>\n<li>ext 负责加载 jre-bin-ext 下面的扩展类</li>\n<li>system 或者说 app 负责加载我们写的 java 类</li>\n</ul>\n<p>这里说一下如何判断两个类不一样<br>\n首先，全限定名称不同；其次，要被不同的类加载器加载。因为每个类加载器都有自己的命名空间，所以不同加载了那么就是不同，即使全名相同。</p>\n<p>所以出现了双亲委派机制，具体的实现也就是 loadClass 这个方法实现的，如果我们自定义类加载器，也就是继承 classLoader 后，重写 loadClass 方法，那么就会破坏双亲委派机制，可以直接指定我们的自定义 loader 去加载指定的类，但是对于 java 核心的类库是不行的，会报错（网上这么说的，具体没试过，sun 公司对于 JVM 的保护吧）</p>\n<p>正常的 loadClass 有几个步骤：</p>\n<ul>\n<li>查缓存，看看有没有；有的话直接加载</li>\n<li>没有，那么交给上层，也就是双亲去加载，直到最高层也就是 bootstrap</li>\n<li>最后调用 findClass 来加载</li>\n</ul>\n<h4 id=\"破坏双亲委派机制\"><a class=\"markdownIt-Anchor\" href=\"#破坏双亲委派机制\">#</a> 破坏双亲委派机制</h4>\n<p>常见的破坏双亲委派机制的场景，常见的有两个：</p>\n<ul>\n<li>热部署，也就是通过直接加载最新的类，完成热部署，但是这个类名是完全相同的，所以要完成类的加载，那么就需要使用不同的类加载器，所以破坏了唯一加载的原则</li>\n<li>SPI 的实现如 JDBC，也就是核心类需要依靠外部类的情况，典型的就是数据库的加载，不同的厂商依据同一套规则给出不同的实现，那么类加载的时候，到上层 bootstrap 只能加载核心的类，但是核心类依赖外部类的实现（也就是 classpath 下的类），那么双亲委派的原则， 当前类所依赖的类也应该由加载当前类的加载器来加载，但是 bootstrap loader 明显是不能加载三方 user 类的。那么这个时候就直接调用线程上下文类加载器完成类的加载。  PS：这边讲一下为什么用线程上下文而不是用 system 直接指定，因为不同的部署环境，他们的类加载器不同，比如 web 等，用的不一定是 system，那么使用线程动态获取，是最合适的。</li>\n<li>tomcat，这边刚开始看还有点摸不着头脑，但是看到后面貌似也就那么回事。因为 web 有应用场景。tomcat 作为 web 的容器，那么有多个 web 应用呢，版本不同但是类的全限定名是相同的，也就是实现不同，这个时候怎么加载，如果交给父亲加载，那么必然就只有一个，不存在不同版本的。所以 tomcat 重写了 loadclass 方法，设计了 webappclassloader。优先加载当前目录下的类，如果没有再一层层往上找。对于 webapp 这一层是破坏了双亲委派的。但是对于 catalinaclassloader 加载 tomcat 内部，shareclassloader，common 等这一层是没有破坏双亲委派的，因为他们需要唯一，都共享还不唯一干啥。</li>\n</ul>\n<p>从这里就可以看出，双亲委派就是为了确保唯一的。所以当我想要不同的版本共存，需要破坏 tomcat。当我一直回溯到上层但是当前的类加载器加载不了我依赖的三方，需要破坏 spi，jdbc，jndi。。</p>\n<p>对于 jspclassloader，这个重写 loadclass 就是监听 update time 来重新进行类加载，从而实现热部署，也就是这个 jsploader 是及时销毁的。</p>\n<p>对于 JDBC 破坏的双亲委派，网上有个说的很好，说见仁见智。我也就的有点这种感觉吧。其主要的核心就是 drivermanager.getconnection 获取三方厂商的 jdbc 实现。但是 drivermanager 是 lib 下的核心类库，也就是通过 bootstrap 加载的。但是类加载机制规定与当前类相关的类需要通过当前类的类加载器来加载。但是这个三方实现的类肯定无法通过 bootstrap 来加载。因为 spi 规定放在了 classpath 的 metainfo/service 下面了。所以在 drivermanager 的初始化里面调用了 serviceloader，直接使用上下文加载器来加载。也就是不是同一个类加载器了。但是正常的话就是回调麻。也就是 bootstrap 加载不了就回来 ext，最终还是要回到 apploader 的。所以见仁见智也是有道理的。</p>\n<p>补充一点，对于 drivermanager 是通过 bootstraploader 加载的，但是其依赖的三方类库，通过类加载机制，无法加载成功，如果不通过调用 context loader 来加载的话就会加载失败。所以破坏了双亲委派。</p>\n<p>这篇讲的很好<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmF6ZWppYW4vYXJ0aWNsZS9kZXRhaWxzLzczNDEzMjky\"> https://blog.csdn.net/javazejian/article/details/73413292</span></p>\n<h3 id=\"bean的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#bean的生命周期\">#</a> Bean 的生命周期</h3>\n<p>对于 bean 的生命周期大致就可以说三个，</p>\n<ul>\n<li>实例化</li>\n<li>填充属性</li>\n<li>初始化</li>\n</ul>\n<p>主要的流程感觉就是加载 xml 或者是注解，然后调用 beanDefinition 反射创建 bean，属性填充，初始化，使用，销毁等等一系列的</p>\n<p>其中涉及到 bean 如果继承了某些类的话，就可以使用钩子来在固定的节点加入一些自定义的处理。例如 aware 就是在属性填充之后，还可以继承 BeanPostProcessor 来在初始化前后进行一些处理</p>\n<p>感觉也就这么多，这边就会涉及到循环依赖吧，按照网上的说法，bean 的实例化包含了 JVM 的一系列过程，感觉是这么回事，，，。</p>\n<h3 id=\"thread的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#thread的生命周期\">#</a> Thread 的生命周期</h3>\n<p><img data-src=\"https://pic.imgdb.cn/item/653c7540c458853aef3b34d9.jpg\" alt=\"\"></p>\n<p>个人说一下理解，</p>\n<ul>\n<li>runnable 的前一个状态必然是 ready，所以 start 之后，也是先 ready 等待时间片的</li>\n<li>至于 waiting 和 timed waiting，直观的也就是 wait 和 sleep 的调用了，也就是加时间的会进入 timed waiting，不会释放锁仅仅让出 cpu</li>\n<li>对于 waiting 和 blocked，感觉是 jvm 层面的东西了，也就是使用 aqs 并没有涉及到操作系统的调度的，也就是 lockSupport.part () 是进入 waiting 状态。但是 synchronized 使用了 monitor 锁的，就会进入 blocked 状态，交由操作系统调度。</li>\n</ul>\n",
            "tags": [
                "Spring",
                "Thread"
            ]
        }
    ]
}